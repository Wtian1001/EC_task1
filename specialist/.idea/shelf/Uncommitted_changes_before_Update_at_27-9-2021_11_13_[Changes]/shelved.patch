Index: NEAT/main_NEAT.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/main_NEAT.py b/NEAT/main_NEAT.py
--- a/NEAT/main_NEAT.py	(revision 41bb8584d54442b48595f32b39c02eba266c9a85)
+++ b/NEAT/main_NEAT.py	(date 1632733146362)
@@ -1,0 +1,166 @@
+################################
+# NEAT ALGORITHM APPLIED TO EVOMAN FRAMEWORK
+# This document is the main and is used to tune the parameters of the NEAT algorithm.
+# It is also used to show figures.
+################################
+
+# imports framework
+import sys, os
+sys.path.insert(0, 'evoman')
+
+# imports other libs
+import numpy as np
+from environment import Environment
+import apply_NEAT
+import csv
+import yaml
+import pandas as pd
+import math
+import itertools
+import figures_NEAT_tuning
+from specialist_controller import NEAT_Controls
+
+# choose this for not using visuals and thus making experiments faster
+headless = True
+if headless:
+    os.environ["SDL_VIDEODRIVER"] = "dummy"
+
+
+# Load the configuration file
+with open("config_main.yml", "r") as ymlfile:
+    cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)
+
+name_experiment = cfg["decision_variables"]["name_experiment"]
+tune_parameters = cfg["decision_variables"]["tune_parameters"] # boolean which decides to tune parameters
+enemy = cfg["experiment_parameters"]["enemy"]
+generations = cfg["experiment_parameters"]["generations"]
+apply_optimization = cfg["decision_variables"]["apply_optimization"]
+show_figures = cfg["decision_variables"]["show_figures"]
+save_figures = cfg["decision_variables"]["save_figures"]
+
+
+if tune_parameters:
+    tuning_parameters = cfg["tuning_parameters"]
+
+run_nr = cfg["experiment_parameters"]["number_of_runs"]  # number of runs per
+
+
+
+
+if not os.path.exists(name_experiment):
+    os.makedirs(name_experiment)
+
+
+
+def change_config_file(config, parameter_names, parameter_values):
+    file = open(config, "r")
+    list_of_lines = file.readlines()
+
+    for jdx, parameter_name in enumerate(parameter_names):
+        line = [idx for idx, s in enumerate(list_of_lines) if parameter_name in s][0]
+        string = list_of_lines[line]
+        name = string[:string.index("=")]
+        list_of_lines[line] = name+"= "+str(parameter_values[jdx])+"\n"
+
+    file = open(config, "w")
+    file.writelines(list_of_lines)
+    file.close()
+
+    return config
+
+def integer_options(series):
+    l_bound = series["l_bound"]
+    u_bound = series["u_bound"]
+    num_var = series["num_variations"]
+
+    options = list(range(math.ceil(l_bound), math.floor(u_bound)+1))
+
+    step_size = int(len(options)/num_var)
+
+    final_options = np.zeros(num_var)
+
+    k = 0
+    for i in range(num_var-1):
+        final_options[i] = options[k]
+        k+=step_size
+
+    final_options[(num_var-1)] = options[(len(options)-1)]
+
+    return np.array(options)
+
+
+def float_options(series):
+    l_bound = series["l_bound"]
+    u_bound = series["u_bound"]
+    num_var = series["num_variations"]
+
+    step_size = (u_bound-l_bound)/(num_var-1)
+
+    options = np.arange(l_bound, (u_bound+step_size), step_size)
+
+    return np.array(options)
+
+def all_combinations(tune_options):
+    all_combinations = list(itertools.product(*tune_options))
+
+    return all_combinations
+
+
+
+def make_parameter_matrix():
+    df = pd.DataFrame([])
+    tune_options = []
+
+    for param in tuning_parameters:
+        df.index = tuning_parameters[param]
+        df[param] = tuning_parameters[param].values()
+
+        if df.loc["type",param] == "integer":
+            tune_options.append(integer_options(df[param]))
+
+        if df.loc["type",param] == "float":
+            tune_options.append(float_options(df[param]))
+
+    parameter_options = all_combinations(tune_options)
+    return parameter_options, df
+
+def run_experiment(env,  config, parameter_options = None, parameter_names=None):
+    if tune_parameters:
+        for parameters in parameter_options:
+            config = change_config_file(config, parameter_names, parameters)
+            for run in range(run_nr):
+                apply_NEAT.run(env, generations, config, str(parameters)+ "_run_"+str(run), name_experiment)
+
+    else:
+        for run in range(run_nr):
+            apply_NEAT.run(env, generations, config, run, name_experiment)
+
+def main(config):
+
+    # initializes simulation in individual evolution mode, for single static enemy.
+    env = Environment(experiment_name=name_experiment,
+                      enemies=[enemy],
+                      playermode="ai",
+                      player_controller=NEAT_Controls(),
+                      enemymode="static",
+                      level=2,
+                      speed="fastest",
+                      randomini="yes")
+
+    # default environment fitness is assumed for experiment
+    env.state_to_log()  # checks environment state
+
+    if tune_parameters:
+        parameter_options, parameter_descriptions = make_parameter_matrix()
+        parameter_names = parameter_descriptions.loc["name", :]
+
+    if apply_optimization:
+        run_experiment(env, config, parameter_options, parameter_names)
+
+    if save_figures or show_figures:
+        figures_NEAT_tuning.make_figures(save_figures, show_figures, name_experiment, parameter_options, parameter_names,run_nr, enemy )
+
+if __name__ == '__main__':
+    local_dir = os.path.dirname(__file__)
+    config_NEAT_path = os.path.join(local_dir, 'config-feedforward')
+    main(config_NEAT_path)
\ No newline at end of file
Index: NEAT/figures_NEAT_tuning.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated on Thu Sep 16 11:32:38 2021\r\n\r\n@author: pjotr\r\nmake figures\r\n\"\"\"\r\nimport csv\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\nfolder = 'test_run_NEAT'\r\ntuning_parameter = \"Stagnation\"\r\nnumber_of_runs = 3\r\nparameter_options = [2,3,4] # needs to be equal to the number of runs\r\nenemy = 2\r\n\r\nfor run in range(number_of_runs):\r\n    df = pd.read_csv(f'{folder}/fitness_data_{run}.csv')\r\n    y = list(df[\"max\"])\r\n    x = list(df.index)\r\n    plt.plot(x,y, label = \"Stagnation param = \"+str(parameter_options[run]))\r\nplt.legend()\r\nplt.xlabel('generation')\r\nplt.ylabel('fitness')\r\nplt.title(f'Fitness over time against enemy:{enemy}')\r\nplt.show()\r\n\r\n\r\n# total_fitness_data = []\r\n# with open(f'{folder}/fitness_data_{run}.csv', newline='', encoding='utf-8') as f:\r\n#     reader = csv.reader(f, delimiter=',', quoting=csv.QUOTE_NONNUMERIC)\r\n#     for row in reader:\r\n#         total_fitness_data.append(row)\r\n#\r\n# enemy, generations, max_health = total_fitness_data[0]\r\n# total_fitness_data = total_fitness_data[1:]\r\n#\r\n# enemy = int(enemy)\r\n# generations = int(generations)\r\n# population_size = len(total_fitness_data)\r\n#\r\n# x = range(generations)\r\n# total_fitness_data = np.array(total_fitness_data)\r\n# fig, ax = plt.subplots()\r\n# ax.plot(x, total_fitness_data[:,0])\r\n# ax.plot(x, total_fitness_data[:,1])\r\n# ax.fill_between(x,\r\n#                 total_fitness_data[:,1] - total_fitness_data[:,2],\r\n#                 total_fitness_data[:,1] + total_fitness_data[:,2], alpha=0.2)\r\n# ax.set_xlim(0, generations-1)\r\n# ax.set_xticks(range(generations))\r\n# plt.ylim(0,100)\r\n# plt.text(0.7*generations, 10, f'Max Fit  = {np.max(total_fitness_data[:,0]).round(2)}')\r\n# plt.text(0.7*generations, 5, f'Max Life= {np.round(max_health, 2)}')\r\n# plt.title(f'Fitness over time against enemy:{int(enemy)}')\r\n# plt.show()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/figures_NEAT_tuning.py b/NEAT/figures_NEAT_tuning.py
--- a/NEAT/figures_NEAT_tuning.py	(revision 41bb8584d54442b48595f32b39c02eba266c9a85)
+++ b/NEAT/figures_NEAT_tuning.py	(date 1632733971747)
@@ -10,49 +10,34 @@
 import numpy as np
 import pandas as pd
 
-folder = 'test_run_NEAT'
-tuning_parameter = "Stagnation"
-number_of_runs = 3
-parameter_options = [2,3,4] # needs to be equal to the number of runs
-enemy = 2
+def make_figures(save_figures, show_figure, name_experiment, parameter_options, parameter_names, number_of_runs, enemy):
+    list_means = []
+    list_max = []
+    list_sdev = []
+
+
+
+    count_run = 0
+    sum_of_maxima = 0
+
+    for  parameter in parameter_options:
+        for count_run in range(number_of_runs):
+            df = pd.read_csv(f'{name_experiment}/fitness_data_{parameter}_run_{count_run}.csv')
 
-for run in range(number_of_runs):
-    df = pd.read_csv(f'{folder}/fitness_data_{run}.csv')
-    y = list(df["max"])
-    x = list(df.index)
-    plt.plot(x,y, label = "Stagnation param = "+str(parameter_options[run]))
-plt.legend()
-plt.xlabel('generation')
-plt.ylabel('fitness')
-plt.title(f'Fitness over time against enemy:{enemy}')
-plt.show()
+            sum_of_maxima += df["max"].max()
+
+        list_max.append(sum_of_maxima/number_of_runs)
+        sum_of_maxima = 0
+
+    print(list_max)
+    plt.hist(list_max)
+    #plt.legend()
+    plt.xlabel('generation')
+    plt.ylabel('fitness')
+    plt.title(f'Fitness over time against enemy:{enemy}')
+
+    if save_figures:
+        plt.savefig("")
+    if show_figure:
+        plt.show()
 
-
-# total_fitness_data = []
-# with open(f'{folder}/fitness_data_{run}.csv', newline='', encoding='utf-8') as f:
-#     reader = csv.reader(f, delimiter=',', quoting=csv.QUOTE_NONNUMERIC)
-#     for row in reader:
-#         total_fitness_data.append(row)
-#
-# enemy, generations, max_health = total_fitness_data[0]
-# total_fitness_data = total_fitness_data[1:]
-#
-# enemy = int(enemy)
-# generations = int(generations)
-# population_size = len(total_fitness_data)
-#
-# x = range(generations)
-# total_fitness_data = np.array(total_fitness_data)
-# fig, ax = plt.subplots()
-# ax.plot(x, total_fitness_data[:,0])
-# ax.plot(x, total_fitness_data[:,1])
-# ax.fill_between(x,
-#                 total_fitness_data[:,1] - total_fitness_data[:,2],
-#                 total_fitness_data[:,1] + total_fitness_data[:,2], alpha=0.2)
-# ax.set_xlim(0, generations-1)
-# ax.set_xticks(range(generations))
-# plt.ylim(0,100)
-# plt.text(0.7*generations, 10, f'Max Fit  = {np.max(total_fitness_data[:,0]).round(2)}')
-# plt.text(0.7*generations, 5, f'Max Life= {np.round(max_health, 2)}')
-# plt.title(f'Fitness over time against enemy:{int(enemy)}')
-# plt.show()
\ No newline at end of file
Index: NEAT/evoman/enemy8.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy8.py b/NEAT/evoman/enemy8.py
new file mode 100644
--- /dev/null	(date 1632487473346)
+++ b/NEAT/evoman/enemy8.py	(date 1632487473346)
@@ -0,0 +1,305 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map3.tmx'
+timeexpire = 1000 # game run limit
+
+# enemy 8 sprite, quickman
+class Enemy(pygame.sprite.Sprite):
+
+
+    def __init__(self, location, *groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.alternate = 1
+        self.just_shoot = 0
+        self.imune = 0
+        self.timeenemy = 0
+        self.twists = []
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+        # defines game mode for player action
+        if game.enemymode == 'static': # enemy controlled by static movements
+
+            if (self.timeenemy >= 1 and self.timeenemy <10)  or (self.timeenemy >= 20 and self.timeenemy <30):
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if self.timeenemy == 1  or self.timeenemy == 20:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy == 9  or self.timeenemy == 29:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            if self.timeenemy >=40 and self.timeenemy <50:
+                atack4 = 1
+            else:
+                atack4 = 0
+
+            if self.timeenemy  == 50:
+                atack5 = 1
+            else:
+                atack5 = 0
+
+            if ( (abs(self.rect.left-game.player.rect.left)<=200 or abs(self.rect.right-game.player.rect.right)<=200)  ) and not self.gun_cooldown:
+                atack6 = 1
+            else:
+                atack6 = 0
+
+
+
+        elif game.enemymode == 'ai': # player controlled by AI algorithm
+
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 6:
+                game.print_logs("ERROR: Enemy 1 controller must return 6 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+            atack5 = actions[4]
+            atack6 = actions[5]
+
+
+
+            if atack6 == 1 and not self.gun_cooldown:
+                atack6 = 1
+            else:
+                atack6 = 0
+
+
+        # If the 'start game' marker is 1.
+        if game.start == 1:
+
+            self.timeenemy += 1 # increments enemy timer
+
+            last = self.rect.copy() # copies last position state of the enemy
+
+            # jumps over the player. It happens twice.
+            if  atack1== 1 :
+                # moves on the axis x
+                self.rect.x += self.direction * 730 * dt
+                if self.resting == 1 and atack2 == 1:
+                    self.dy = -900
+                    self.resting = 0
+
+                # enemy turns to the players direction
+                if atack3 == 1:
+
+                    if game.enemymode == 'static':
+                        if game.player.rect.right < self.rect.left:
+                            self.direction = -1
+                        if game.player.rect.left > self.rect.right:
+                            self.direction = 1
+                    else:
+                        self.direction = self.direction * -1
+
+            # runs in the player's direction, after jumping twice
+            elif atack4 == 1 :
+                self.rect.x += self.direction * 900 * dt
+
+            # reinicializes enemy timer
+            elif atack5 == 1:
+                self.timeenemy = 0
+
+            # throws a bullet over the player when enemy is jumping and right over him
+            if self.resting == 0 and self.just_shoot == 0 and atack6 == 1:
+
+                self.shooting = 5
+
+                self.gun_cooldown = 5
+
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                self.just_shoot = 1
+
+                rand = 3
+                # shoots from 1 to 3 bullets
+                for i in range(0,rand):
+                    self.twists.append(Bullet_e8((self.rect.x+(i*60) ,self.rect.y ), i, self.direction, len(self.twists), game.sprite_e))
+
+            # decreases time for bullets limitation
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)
+
+            # animation, running enemy images alternation
+            if self.direction > 0:
+                direction = SpriteConstants.RIGHT
+            else:
+                direction = SpriteConstants.LEFT
+
+            if self.alternate == 1:
+                self.updateSprite(SpriteConstants.START_RUNNING, direction)
+            if self.alternate == 4 or self.alternate == 10:
+                self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+            if self.alternate == 7:
+                self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+            self.alternate += 1
+            if self.alternate > 12:
+                self.alternate = 1
+
+            #  changes the image when enemy jumps
+            if self.resting == 0:
+               if self.direction == -1:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+               else:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*0.3))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*0.3))
+
+                # sets flag to change the player image when he is hurt
+                game.player.hurt = 5
+
+            #  gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+                    self.just_shoot = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left  and last.bottom>cell.top:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right   and last.bottom>cell.top:
+                    new.left = cell.right
+
+            # hurt enemy animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+            # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+
+# enemy's bullet
+class Bullet_e8(pygame.sprite.Sprite):
+
+    image = pygame.image.load('evoman/images/bullet2_l.png')
+
+    def __init__(self, location, direction, n, n_twist, *groups):
+        super(Bullet_e8, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.lifespan = 70
+        self.n = n
+        self.n_twist = n_twist
+
+
+
+    def update(self, dt, game):
+
+
+        self.lifespan -= 1 # decreases bullet's timer
+
+
+        # moves the bullets up after sometime
+        if self.lifespan < 40:
+            self.rect.y -=  700 * dt
+        else:
+            self.rect.y +=  500 * dt # moves the bullets down when it is shoot
+            self.rect.y = min(410,self.rect.y) # preevens bullets from going away
+
+
+        # moves the bullet on the axis x according to the player's direction
+        if not (abs(self.rect.left-game.player.rect.left)<=10 or abs(self.rect.right-game.player.rect.right)<=10):
+            if game.player.rect.left < self.rect.left:
+               self.rect.x -= (400) * dt
+            else:
+               self.rect.x += (400) * dt
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, according to the difficult level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+            game.player.hurt = 5 # sets flag to change the player image when he is hurt
Index: NEAT/evoman/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/player.py b/NEAT/evoman/player.py
new file mode 100644
--- /dev/null	(date 1632487473346)
+++ b/NEAT/evoman/player.py	(date 1632487473346)
@@ -0,0 +1,351 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import struct
+import binascii
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import *
+
+
+# player proctile
+class Bullet_p(pygame.sprite.Sprite):
+
+
+    image = pygame.image.load('evoman/images/bullet_r.png')
+
+    def __init__(self, location, direction, n_twist, *groups):
+        super(Bullet_p, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+
+        self.n_twist = n_twist
+
+        # fits image according to the side the player is turned to
+        if self.direction == 1:
+            self.image = pygame.image.load('evoman/images/bullet_r.png')
+        else:
+            self.image = pygame.image.load('evoman/images/bullet_l.png')
+
+
+
+    def update(self, dt, game):
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right<1 or self.rect.left>736 or  self.rect.top <1 or self.rect.bottom>512 :
+            self.kill()
+            game.player.twists[self.n_twist] = None
+            return
+
+        self.rect.x += self.direction * 600 * dt    # moving on the X axis (left or tight). It adds 600*dt forward at each general game loop loop iteration, where dt controls the frames limit.
+
+        # checks collision of player's bullet with the enemy
+        if self.rect.colliderect(game.enemy.rect):
+
+            # if enemy is not imune
+            if game.enemy.imune == 0:
+                # enemy loses life points, according to the difficult level of the game (the more difficult, the less it loses)
+                game.enemy.life = max(0, game.enemy.life-(20/game.level))
+
+                if game.enemyn == 4:
+                    # makes enemy imune to player's shooting.
+                    game.enemy.imune = 1
+
+
+            # removes the bullet off the screen after collision.
+            self.kill()
+            game.player.twists[self.n_twist] = None
+
+            game.enemy.hurt = 5
+
+
+
+
+# player sprite
+class Player(pygame.sprite.Sprite):
+
+
+
+    def __init__(self, location, enemyn, level, *groups):
+        super(Player, self).__init__(*groups)
+
+
+        self.spriteDefinition = SpriteDefinition('evoman/images/EvoManSprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.resting = 0
+        self.dy = 0
+        self.direction = 1
+        self.alternate = 1
+        self.gun_cooldown = 0
+        self.max_life = 100
+        self.life = self.max_life
+        self.atacked = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.inwater = 0
+        self.twists = []
+        self.vx = 0
+        self.vy = 0
+        self.hy = 0
+        self.sensors = None
+
+
+
+    def update(self, dt, game):
+
+
+        # if the enemies are not atacking with the freezing atack (prevents player from making any movements or atacking) and also the 'start game' marker is 1.
+        if game.freeze_p == 0  and game.start == 1:
+
+            # checks water environment flag to regulate movements speed
+            if self.inwater == 1:
+                self.vx = 0.5
+                self.vy = 0.5
+                self.hy = -2000
+            else:
+                self.vx = 1
+                self.vy = 1
+                self.hy = -900
+
+            # defines game mode for player action
+
+            if game.playermode == 'human': # player controlled by keyboard/joystick
+
+                # if joystick is connected, initializes it.
+                if game.joy > 0:
+                    joystick = pygame.joystick.Joystick(0)
+                    joystick.init()
+
+                # tests if the button/key was pressed or released.
+                # if the player is jumping, the release stops the jump before its maximum high is achieved
+
+                press = 0
+                release = 0
+                for event in  game.event:
+                    if event.type == pygame.JOYBUTTONDOWN or event.type == pygame.KEYDOWN:
+                        press = 1
+                    else:
+                        press = 0
+
+                    if event.type == pygame.JOYBUTTONUP or event.type == pygame.KEYUP:
+                        release = 1
+                    else:
+                        release = 0
+
+                # gets pressed key value
+                key = pygame.key.get_pressed()
+
+                # gets joystick value for axis x (left/right)
+                left = 0
+                if game.joy > 0:
+                    if round(joystick.get_axis(0)) == -1:
+                        left = 1
+                if key[pygame.K_LEFT]:
+                    left = 1
+
+                right = 0
+                if game.joy > 0:
+                    if round(joystick.get_axis(0)) == 1:
+                        right = 1
+                if key[pygame.K_RIGHT]:
+                    right  = 1
+
+                # gets joystick/key value for jumping
+                jump = 0
+                if game.joy > 0:
+                    if int(joystick.get_button(2)) == 1 and press == 1:
+                            jump = 1
+                if key[pygame.K_SPACE] and press == 1:
+                    jump = 1
+
+                # gets joystick/key value for shooting
+                shoot = 0
+                if game.joy > 0:
+                    if int(joystick.get_button(3)) == 1 and press == 1:
+                            shoot = 1
+                if key[pygame.K_LSHIFT] and press == 1:
+                    shoot = 1
+
+            elif game.playermode == 'ai': # player controlled by AI algorithm
+
+
+                # calls the controller providing game sensors
+                actions = game.player_controller.control(self.sensors.get(game), game.pcont)
+                if len(actions) < 5:
+                    game.print_logs("ERROR: Player controller must return 5 decision variables.")
+                    sys.exit(0)
+
+                left = actions[0]
+                right = actions[1]
+                jump = actions[2]
+                shoot = actions[3]
+                release = actions[4]
+
+            # if the button is released before the jumping maximum height, them player stops going up.
+            if release == 1 and self.resting == 0:
+                self.dy = 0
+
+            # copies last position state of the player
+            last = self.rect.copy()
+
+            # movements on the axis x (left)
+            if left:
+
+                self.rect.x -= 200 * dt * self.vx
+                self.direction = -1
+
+                # animation, running images alternation
+                if self.alternate == 1:
+                    self.updateSprite(SpriteConstants.START_RUNNING, SpriteConstants.LEFT)
+                if self.alternate == 4 or self.alternate == 10:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP1, SpriteConstants.LEFT)
+                if self.alternate == 7:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP2, SpriteConstants.LEFT)
+
+                self.alternate += 1
+                if self.alternate > 12:
+                    self.alternate = 1
+
+            # movements on the axis x (right)
+            elif right:
+
+                self.rect.x += 200 * dt * self.vx
+                self.direction = 1
+
+                # animation, running player images alternation
+                if self.alternate == 1:
+                    self.updateSprite(SpriteConstants.START_RUNNING, SpriteConstants.RIGHT)
+                if self.alternate == 4 or self.alternate == 10:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP1, SpriteConstants.RIGHT)
+                if self.alternate == 7:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP2, SpriteConstants.RIGHT)
+
+                self.alternate += 1
+                if self.alternate > 12:
+                    self.alternate = 1
+
+
+            else:
+                # animation, standing up images
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+
+            # if player is touching the floor, he is allowed to jump
+            if  self.resting == 1  and jump == 1:
+                    self.dy =  self.hy
+
+            # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt * self.vy
+
+            #  changes the image when player jumps
+            if self.resting == 0 :
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+
+            new = self.rect # copies new (after movement) position state of the player
+
+            # controls screen walls and platforms limits agaist player
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left and last.bottom>cell.top:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right and last.bottom>cell.top:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1 # player touches the floor
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+            # shoots, limiting time between bullets.
+            if  shoot == 1 and not self.gun_cooldown:
+
+                self.shooting = 5
+                self.atacked = 1 # marks if the player has atacked enemy
+
+
+                # creates bullets objects according to the direction.
+                if self.direction > 0:
+                    self.twists.append(Bullet_p(self.rect.midright, 1, len(self.twists), game.sprite_p))
+
+                else:
+                     self.twists.append(Bullet_p(self.rect.midleft, -1, len(self.twists), game.sprite_p))
+
+                self.gun_cooldown = 0.4 # marks time to the bullet for allowing next bullets
+
+                # sound effects
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi003.wav')
+                    c = pygame.mixer.Channel(2)
+                    c.set_volume(1)
+                    c.play(sound)
+
+            else:
+                self.atacked = 0
+
+
+
+            # decreases time for limitating bullets
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)
+
+            # hurt player animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -= 1
+            self.hurt = max(0,self.hurt)
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+            # shooting animation
+            if self.shooting > 0:
+                if self.resting == 0:
+                    if self.direction == -1:
+                        self.updateSprite(SpriteConstants.SHOOTING_JUMPING, SpriteConstants.LEFT)
+                    else:
+                        self.updateSprite(SpriteConstants.SHOOTING_JUMPING, SpriteConstants.RIGHT)
+                else:
+                    if self.direction == -1:
+                        self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                    else:
+                        self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            # kills player in case he touches killers stuff, like spikes.
+            for cell in game.tilemap.layers['triggers'].collide(self.rect, 'killers'):
+                game.player.life = 0
+
+            # focuses screen center on player
+            game.tilemap.set_focus(new.x, new.y)
+        else:
+            game.tilemap.set_focus(self.rect.x, self.rect.y)
+
+
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
Index: NEAT/evoman/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/README.md b/NEAT/evoman/README.md
new file mode 100644
--- /dev/null	(date 1632487473362)
+++ b/NEAT/evoman/README.md	(date 1632487473362)
@@ -0,0 +1,12 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+EvoMan is a framework for testing optimization algorithms in General Video Game Playing research field. The environment provides multiple 2D platform games to be run in several parameterized simulation modes.
+
+Needs: numpy and pygame
+
+ 
+ 
Index: NEAT/evoman/roles.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/roles.tsx b/NEAT/evoman/roles.tsx
new file mode 100644
--- /dev/null	(date 1632487473362)
+++ b/NEAT/evoman/roles.tsx	(date 1632487473362)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tileset name="plataform2" tilewidth="32" tileheight="32">
+ <image source="evoman/images/plataform2.jpg" width="150" height="93"/>
+</tileset>
Index: NEAT/evoman/roles2.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/roles2.tsx b/NEAT/evoman/roles2.tsx
new file mode 100644
--- /dev/null	(date 1632487473377)
+++ b/NEAT/evoman/roles2.tsx	(date 1632487473377)
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tileset name="roles" tilewidth="32" tileheight="32">
+ <image source="evoman/images/roles.png" trans="ff00ff" width="450" height="32"/>
+ <tile id="0">
+  <properties>
+   <property name="player" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="1">
+  <properties>
+   <property name="enemy" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="2">
+  <properties>
+   <property name="exit" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="3">
+  <properties>
+   <property name="reverse" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="4">
+  <properties>
+   <property name="life" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="5">
+  <properties>
+   <property name="hd" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="6">
+  <properties>
+   <property name="plat" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="7">
+  <properties>
+   <property name="gun" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="8">
+  <properties>
+   <property name="spike" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="9">
+  <properties>
+   <property name="spike2" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="10">
+  <properties>
+   <property name="score" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="11">
+  <properties>
+   <property name="medicine" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="12">
+  <properties>
+   <property name="spike3" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="13">
+  <properties>
+   <property name="spike4" value="yes"/>
+  </properties>
+ </tile>
+</tileset>
Index: NEAT/evoman/roles3.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/roles3.tsx b/NEAT/evoman/roles3.tsx
new file mode 100644
--- /dev/null	(date 1632487473377)
+++ b/NEAT/evoman/roles3.tsx	(date 1632487473377)
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tileset name="roles" tilewidth="32" tileheight="32">
+ <image source="evoman/images/roles.png" trans="ff00ff" width="450" height="32"/>
+ <tile id="0">
+  <properties>
+   <property name="player" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="1">
+  <properties>
+   <property name="enemy" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="2">
+  <properties>
+   <property name="exit" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="3">
+  <properties>
+   <property name="reverse" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="4">
+  <properties>
+   <property name="life" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="5">
+  <properties>
+   <property name="hd" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="6">
+  <properties>
+   <property name="plat" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="7">
+  <properties>
+   <property name="gun" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="8">
+  <properties>
+   <property name="spike" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="9">
+  <properties>
+   <property name="spike2" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="10">
+  <properties>
+   <property name="score" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="11">
+  <properties>
+   <property name="medicine" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="12">
+  <properties>
+   <property name="spike3" value="yes"/>
+  </properties>
+ </tile>
+ <tile id="13">
+  <properties>
+   <property name="spike4" value="yes"/>
+  </properties>
+ </tile>
+</tileset>
Index: NEAT/evoman/roles4.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/roles4.tsx b/NEAT/evoman/roles4.tsx
new file mode 100644
--- /dev/null	(date 1632487473377)
+++ b/NEAT/evoman/roles4.tsx	(date 1632487473377)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<tileset name="spikes4" tilewidth="32" tileheight="32">
+ <image source="evoman/images/spikes4.png" trans="ff00ff" width="94" height="33"/>
+</tileset>
Index: NEAT/evoman/sensors.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/sensors.py b/NEAT/evoman/sensors.py
new file mode 100644
--- /dev/null	(date 1632487473377)
+++ b/NEAT/evoman/sensors.py	(date 1632487473377)
@@ -0,0 +1,49 @@
+import numpy
+import struct
+import binascii
+
+# sensors for the controllers
+class Sensors():
+
+
+    def get(self, game):
+
+
+        # calculates vertical and horizontal distances between sprites centers
+
+        posx_p = game.player.rect.left +((game.player.rect.right - game.player.rect.left)/2)
+        posy_p = game.player.rect.bottom +((game.player.rect.top - game.player.rect.bottom)/2)
+        posx_e = game.enemy.rect.left +((game.enemy.rect.right - game.enemy.rect.left)/2)
+        posy_e = game.enemy.rect.bottom +((game.enemy.rect.top - game.enemy.rect.bottom)/2)
+
+        param_values = [ posx_p-posx_e, posy_p-posy_e, game.player.direction, game.enemy.direction]
+
+        # calculates vertical and horizontal distances between player and the center of enemy's bullets
+        for i in range(0,len(game.enemy.twists)):
+            if game.enemy.twists[i] != None:
+                posx_be = game.enemy.twists[i].rect.left +((game.enemy.twists[i].rect.right - game.enemy.twists[i].rect.left)/2)
+                posy_be = game.enemy.twists[i].rect.bottom +((game.enemy.twists[i].rect.top - game.enemy.twists[i].rect.bottom)/2)
+                param_values.append(posx_p-posx_be)
+                param_values.append(posy_p-posy_be)
+
+        # treats cases when not all bullets are used
+        for i in range(0,8-len([t for t in game.enemy.twists if t != None])):
+            param_values.append(0)
+            param_values.append(0)
+
+        # applies several transformations to input variables (sensors)
+        if game.inputscoded == "yes":
+
+            types = struct.Struct('q q q q q q q q q q q q q q q q q q q q') # defines the data types of each item of the array that will be packed. (q=int, f=flo)
+            packed_data = types.pack(*param_values)  # packs data as struct
+            coded_variables =  binascii.hexlify(packed_data)  # converts packed data to an hexadecimal string
+            coded_variables = [coded_variables[i:i+2] for i in range(0, len(coded_variables), 2)] # breaks hexadecimal string in bytes.
+            coded_variables = numpy.array(map(lambda y: int(y, 16), coded_variables))  # converts bytes to integer
+
+            param_values = coded_variables
+
+
+        self.sensors = param_values # defines sensors state
+
+
+        return numpy.array(self.sensors)
Index: NEAT/evoman/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/controller.py b/NEAT/evoman/controller.py
new file mode 100644
--- /dev/null	(date 1632487473393)
+++ b/NEAT/evoman/controller.py	(date 1632487473393)
@@ -0,0 +1,21 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import numpy
+
+class Controller(object):
+
+
+    def control(self, params, cont = None):
+
+        action1 = numpy.random.choice([1,0])
+        action2 = numpy.random.choice([1,0])
+        action3 = numpy.random.choice([1,0])
+        action4 = numpy.random.choice([1,0])
+        action5 = numpy.random.choice([1,0])
+        action6 = numpy.random.choice([1,0])
+
+        return [action1, action2, action3, action4, action5, action6]
Index: NEAT/evoman/environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/environment.py b/NEAT/evoman/environment.py
new file mode 100644
--- /dev/null	(date 1632487473393)
+++ b/NEAT/evoman/environment.py	(date 1632487473393)
@@ -0,0 +1,606 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import gzip
+import pickle
+import numpy
+import pygame
+from pygame.locals import *
+import struct
+import tmx
+
+from player import *
+from controller import Controller
+
+
+# main class
+class Environment(object):
+
+
+    # simulation parameters
+    def __init__(self,
+                 experiment_name='test',
+                 multiplemode="no",           # yes or no
+                 enemies=[1],                 # array with 1 to 8 items, values from 1 to 8
+                 loadplayer="yes",            # yes or no
+                 loadenemy="yes",             # yes or no
+                 level=2,                     # integer
+                 playermode="ai",             # ai or human
+                 enemymode="static",          # ai or static
+                 speed="fastest",             # normal or fastest
+                 inputscoded="no",            # yes or no
+                 randomini="no",              # yes or no
+                 sound="off",                  # on or off
+                 contacthurt="player",        # player or enemy
+                 logs="on",                   # on or off
+                 savelogs="yes",              # yes or no
+                 clockprec="low",
+                 timeexpire=3000,             # integer
+                 overturetime=100,            # integer
+                 solutions=None,              # any
+                 fullscreen=False,            # True or False
+                 player_controller=None,      # controller object
+                 enemy_controller=None,      # controller object
+                 use_joystick=False):
+
+
+        # initializes parameters
+
+        self.experiment_name = experiment_name
+        self.multiplemode = multiplemode
+        self.enemies = enemies
+        self.enemyn = enemies[0] # initial current enemy
+        self.loadplayer = loadplayer
+        self.loadenemy = loadenemy
+        self.level = level
+        self.playermode = playermode
+        self.enemymode = enemymode
+        self.speed = speed
+        self.inputscoded = inputscoded
+        self.randomini = randomini
+        self.sound = sound
+        self.contacthurt = contacthurt
+        self.logs = logs
+        self.fullscreen = fullscreen
+        self.savelogs = savelogs
+        self.clockprec = clockprec
+        self.timeexpire = timeexpire
+        self.overturetime = overturetime
+        self.solutions = solutions
+        self.joy = 0
+        self.use_joystick = use_joystick
+
+
+        # initializes default random controllers
+
+        if self.playermode == "ai" and player_controller == None:
+            self.player_controller = Controller()
+        else:
+            self.player_controller =  player_controller
+
+        if self.enemymode == "ai" and enemy_controller == None:
+            self.enemy_controller = Controller()
+        else:
+            self.enemy_controller =  enemy_controller
+
+
+        # initializes log file
+        if self.logs  == "on" and self.savelogs == "yes":
+            file_aux  = open(self.experiment_name+'/evoman_logs.txt','w')
+            file_aux.close()
+
+
+        # initializes pygame library
+        pygame.init()
+        self.print_logs("MESSAGE: Pygame initialized for simulation.")
+
+        # initializes sound library for playing mode
+        if self.sound == "on":
+            pygame.mixer.init()
+            self.print_logs("MESSAGE: sound has been turned on.")
+
+        # initializes joystick library
+        if self.use_joystick:
+            pygame.joystick.init()
+            self.joy = pygame.joystick.get_count()
+
+        self.clock = pygame.time.Clock() # initializes game clock resource
+        
+        if self.fullscreen:
+            flags =  DOUBLEBUF  |  FULLSCREEN
+        else:
+            flags =  DOUBLEBUF
+
+        self.screen = pygame.display.set_mode((736, 512), flags)
+
+        self.screen.set_alpha(None) # disables uneeded alpha
+        pygame.event.set_allowed([QUIT, KEYDOWN, KEYUP]) # enables only needed events
+
+        self.load_sprites()
+
+
+
+    def load_sprites(self):
+
+        # loads enemy and map
+        enemy = __import__('enemy'+str(self.enemyn))
+        self.tilemap = tmx.load(enemy.tilemap, self.screen.get_size())  # map
+
+        self.sprite_e = tmx.SpriteLayer()
+        start_cell = self.tilemap.layers['triggers'].find('enemy')[0]
+        self.enemy = enemy.Enemy((start_cell.px, start_cell.py), self.sprite_e)
+        self.tilemap.layers.append(self.sprite_e)  # enemy
+
+        # loads player
+        self.sprite_p = tmx.SpriteLayer()
+        start_cell = self.tilemap.layers['triggers'].find('player')[0]
+        self.player = Player((start_cell.px, start_cell.py), self.enemyn, self.level, self.sprite_p)
+        self.tilemap.layers.append(self.sprite_p)
+
+        self.player.sensors = Sensors()
+        self.enemy.sensors = Sensors()
+
+
+    # updates environment with backup of current solutions in simulation
+    def get_solutions(self):
+        return self.solutions
+
+
+        # method for updating solutions bkp in simulation
+    def update_solutions(self, solutions):
+        self.solutions = solutions
+
+
+    # method for updating simulation parameters
+    def update_parameter(self, name, value):
+
+        if type(value) is str:
+            exec('self.'+name +"= '"+ value+"'")
+        else:
+            exec('self.'+name +"= "+ str(value))
+
+        self.print_logs("PARAMETER CHANGE: "+name+" = "+str(value))
+
+
+
+    def print_logs(self, msg):
+        if self.logs == "on":
+            print('\n'+msg) # prints log messages to screen
+
+            if self.savelogs == "yes": # prints log messages to file
+                file_aux  = open(self.experiment_name+'/evoman_logs.txt','a')
+                file_aux.write('\n\n'+msg)
+                file_aux.close()
+
+
+    def get_num_sensors(self):
+
+        if hasattr(self, 'enemy') and self.enemymode == "ai":
+            return  len(self.enemy.sensors.get(self))
+        else:
+            if hasattr(self, 'player') and self.playermode == "ai":
+                return len(self.player.sensors.get(self))
+            else:
+                return 0
+
+
+    # writes all variables related to game state into log
+    def state_to_log(self):
+
+
+        self.print_logs("########## Simulation state - INI ###########")
+        if self.solutions == None:
+            self.print_logs("# solutions # : EMPTY ")
+        else:
+            self.print_logs("# solutions # : LOADED ")
+
+        self.print_logs("# sensors # : "+ str( self.get_num_sensors() ))
+        self.print_logs(" ------  parameters ------  ")
+        self.print_logs("# contact hurt (training agent) # : "  +self.contacthurt)
+
+        self.print_logs("multiple mode: "+self.multiplemode)
+
+        en = ''
+        for e in self.enemies:
+            en += ' '+str(e)
+        self.print_logs("enemies list:"+ en)
+
+        self.print_logs("current enemy: " +str(self.enemyn))
+        self.print_logs("player mode: " +self.playermode)
+        self.print_logs("enemy mode: "  +self.enemymode)
+        self.print_logs("level: " +str(self.level))
+        self.print_logs("clock precision: "+ self.clockprec)
+        self.print_logs("inputs coded: "  +self.inputscoded)
+        self.print_logs("random initialization: "  +self.randomini)
+        self.print_logs("expiration time: "  +str(self.timeexpire))
+        self.print_logs("speed: " +self.speed)
+        self.print_logs("load player: " +self.loadplayer)
+        self.print_logs("load enemy: " +self.loadenemy)
+        self.print_logs("sound: "  +self.sound)
+        self.print_logs("overture time: "  +str(self.overturetime))
+        self.print_logs("logs: "+self.logs)
+        self.print_logs("save logs: "+self.savelogs)
+        self.print_logs("########## Simulation state - END ###########")
+
+
+
+    # exports current environment state to files
+    def save_state(self):
+
+        # saves configuration file for simulation parameters
+        file_aux  = open(self.experiment_name+'/evoman_paramstate.txt','w')
+        en = ''
+        for e in self.enemies:
+            en += ' '+str(e)
+        file_aux.write("\nenemies"+ en)
+        file_aux.write("\ntimeexpire "  +str(self.timeexpire))
+        file_aux.write("\nlevel " +str(self.level))
+        file_aux.write("\nenemyn " +str(self.enemyn))
+        file_aux.write("\noverturetime "  +str(self.overturetime))
+        file_aux.write("\nplayermode " +self.playermode)
+        file_aux.write("\nenemymode "  +self.enemymode)
+        file_aux.write("\ncontacthurt "  +self.contacthurt)
+        file_aux.write("\nclockprec "+ self.clockprec)
+        file_aux.write("\ninputscoded "  +self.inputscoded)
+        file_aux.write("\nrandomini "  +self.randomini)
+        file_aux.write("\nmultiplemode "+self.multiplemode)
+        file_aux.write("\nspeed " +self.speed)
+        file_aux.write("\nloadplayer " +self.loadplayer)
+        file_aux.write("\nloadenemy " +self.loadenemy)
+        file_aux.write("\nsound "  +self.sound)
+        file_aux.write("\nlogs "+self.logs)
+        file_aux.write("\nsavelogs "+self.savelogs)
+        file_aux.close()
+
+        # saves state of solutions in the simulation
+        file = gzip.open(self.experiment_name+'/evoman_solstate', 'w', compresslevel = 5)
+        pickle.dump(self.solutions, file, protocol=2)
+        file.close()
+
+
+        self.print_logs("MESSAGE: state has been saved to files.")
+
+
+
+    # loads a state for environment from files
+    def load_state(self):
+
+
+        try:
+
+            # loads parameters
+            state = open(self.experiment_name+'/evoman_paramstate.txt','r')
+            state = state.readlines()
+            for idp,p in enumerate(state):
+                pv = p.split(' ')
+
+                if idp>0:    # ignore first line
+                    if idp==1: # enemy list
+                        en = []
+                        for i in range(1,len(pv)):
+                            en.append(int(pv[i].rstrip('\n')))
+                        self.update_parameter(pv[0], en)
+                    elif idp<6: # numeric params
+                        self.update_parameter(pv[0], int(pv[1].rstrip('\n')))
+                    else: # string params
+                        self.update_parameter(pv[0], pv[1].rstrip('\n'))
+
+            # loads solutions
+            file = gzip.open(self.experiment_name+'/evoman_solstate')
+            self.solutions =  pickle.load(file, encoding='latin1')
+            self.print_logs("MESSAGE: state has been loaded.")
+
+        except IOError:
+            self.print_logs("ERROR: could not load state.")
+
+
+
+
+    def checks_params(self):
+
+        # validates parameters values
+
+        if self.multiplemode == "yes" and len(self.enemies) < 2:
+            self.print_logs("ERROR: 'enemies' must contain more than one enemy for multiple mode.")
+            sys.exit(0)
+
+        if self.enemymode not in ('static','ai'):
+            self.print_logs("ERROR: 'enemy mode' must be 'static' or 'ai'.")
+            sys.exit(0)
+
+        if self.playermode not in ('human','ai'):
+            self.print_logs("ERROR: 'player mode' must be 'human' or 'ai'.")
+            sys.exit(0)
+
+        if self.loadplayer not in ('yes','no'):
+            self.print_logs("ERROR: 'load player' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.loadenemy not in ('yes','no'):
+            self.print_logs("ERROR: 'load enemy' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.inputscoded not in ('yes','no'):
+            self.print_logs("ERROR: 'inputs coded' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.multiplemode not in ('yes','no'):
+            self.print_logs("ERROR: 'multiplemode' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.randomini not in ('yes','no'):
+            self.print_logs("ERROR: 'random ini' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.savelogs not in ('yes','no'):
+            self.print_logs("ERROR: 'save logs' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.speed not in ('normal','fastest'):
+            self.print_logs("ERROR: 'speed' value must be 'normal' or 'fastest'.")
+            sys.exit(0)
+
+        if self.logs not in ('on','off'):
+            self.print_logs("ERROR: 'logs' value must be 'on' or 'off'.")
+            sys.exit(0)
+
+        if self.clockprec not in ('low','medium'):
+            self.print_logs("ERROR: 'clockprec' value must be 'low' or 'medium'.")
+            sys.exit(0)
+
+        if self.sound not in ('on','off'):
+            self.print_logs("ERROR: 'sound' value must be 'on' or 'off'.")
+            sys.exit(0)
+
+        if self.contacthurt not in ('player','enemy'):
+            self.print_logs("ERROR: 'contacthurt' value must be 'player' or 'enemy'.")
+            sys.exit(0)
+
+        if type(self.timeexpire) is not int:
+            self.print_logs("ERROR: 'timeexpire' must be integer.")
+            sys.exit(0)
+
+        if type(self.level) is not int:
+            self.print_logs("ERROR: 'level' must be integer.")
+            sys.exit(0)
+
+        if type(self.overturetime) is not int:
+            self.print_logs("ERROR: 'overturetime' must be integer.")
+            sys.exit(0)
+
+
+        # checks parameters consistency
+
+        if self.multiplemode == "no" and len(self.enemies) > 1:
+            self.print_logs("MESSAGE: there is more than one enemy in 'enemies' list although the mode is not multiple.")
+
+        if self.level < 1 or self.level > 3:
+            self.print_logs("MESSAGE: 'level' chosen is out of recommended (tested).")
+
+
+
+
+            # default fitness function for single solutions
+    def fitness_single(self):
+        return 0.9*(100 - self.get_enemylife()) + 0.1*self.get_playerlife() - numpy.log(self.get_time())
+
+    # default fitness function for consolidating solutions among multiple games
+    def cons_multi(self,values):
+        return values.mean() - values.std()
+
+    # measures the energy of the player
+    def get_playerlife(self):
+        return self.player.life
+
+    # measures the energy of the enemy
+    def get_enemylife(self):
+        return self.enemy.life
+
+    # gets run time
+    def get_time(self):
+        return self.time
+
+
+    # runs game for a single enemy
+    def run_single(self,enemyn,pcont,econt):
+
+        # sets controllers
+        self.pcont = pcont
+        self.econt = econt
+
+        self.checks_params()
+
+
+        self.enemyn = enemyn # sets the current enemy
+        ends = 0
+        self.time = 0
+        self.freeze_p = False
+        self.freeze_e = False
+        self.start = False
+
+        enemy = __import__('enemy'+str(self.enemyn))
+
+        self.load_sprites()
+
+
+        # game main loop
+
+        while 1:
+
+            # adjusts frames rate for defining game speed
+
+            if self.clockprec == "medium":  # medium clock precision
+                if self.speed == 'normal':
+                    self.clock.tick_busy_loop(30)
+                elif self.speed == 'fastest':
+                    self.clock.tick_busy_loop()
+
+            else:   # low clock precision
+
+                if self.speed == 'normal':
+                    self.clock.tick(30)
+                elif self.speed == 'fastest':
+                    self.clock.tick()
+
+
+            # game timer
+            self.time += 1
+            if self.playermode == "human" or self.sound == "on":
+                # sound effects
+                if self.sound == "on" and self.time == 1:
+                    sound = pygame.mixer.Sound('evoman/sounds/open.wav')
+                    c = pygame.mixer.Channel(1)
+                    c.set_volume(1)
+                    c.play(sound,loops=10)
+
+                if self.time > self.overturetime: # delays game start a little bit for human mode
+                    self.start = True
+            else:
+                self.start = True
+
+
+            # checks screen closing button
+            self.event = pygame.event.get()
+            for event in  self.event:
+                if event.type == pygame.QUIT:
+                    return
+                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                    return
+
+            # updates objects and draws its itens on screen
+#            self.screen.fill((250,250,250))
+            self.tilemap.update( 33 / 1000., self)
+#            self.tilemap.draw(self.screen)
+
+            # player life bar
+#            vbar = int(100 *( 1-(self.player.life/float(self.player.max_life)) ))
+#            pygame.draw.line(self.screen, (0,   0,   0), [40, 40],[140, 40], 2)
+#            pygame.draw.line(self.screen, (0,   0,   0), [40, 45],[140, 45], 5)
+#            pygame.draw.line(self.screen, (150,24,25),   [40, 45],[140 - vbar, 45], 5)
+#            pygame.draw.line(self.screen, (0,   0,   0), [40, 49],[140, 49], 2)
+
+            # enemy life bar
+#            vbar = int(100 *( 1-(self.enemy.life/float(self.enemy.max_life)) ))
+#            pygame.draw.line(self.screen, (0,   0,   0), [590, 40],[695, 40], 2)
+#            pygame.draw.line(self.screen, (0,   0,   0), [590, 45],[695, 45], 5)
+#            pygame.draw.line(self.screen, (194,118,55),  [590, 45],[695 - vbar, 45], 5)
+#            pygame.draw.line(self.screen, (0,   0,   0), [590, 49],[695, 49], 2)
+
+
+            #gets fitness for training agents
+            fitness = self.fitness_single()
+
+
+            # returns results of the run
+            def return_run():
+                self.print_logs("RUN: run status: enemy: "+str(self.enemyn)+"; fitness: " + str(fitness) + "; player life: " + str(self.player.life)  + "; enemy life: " + str(self.enemy.life) + "; time: " + str(self.time))
+
+                return  fitness, self.player.life, self.enemy.life, self.time
+
+
+
+            if self.start == False and self.playermode == "human":
+
+                myfont = pygame.font.SysFont("Comic sams", 100)
+                pygame.font.Font.set_bold
+                self.screen.blit(myfont.render("Player", 1,  (150,24,25)), (50, 180))
+                self.screen.blit(myfont.render("  VS  ", 1,  (50,24,25)), (250, 180))
+                self.screen.blit(myfont.render("Enemy "+str(self.enemyn), 1,  (194,118,55)), (400, 180))
+
+
+            # checks player life status
+            if self.player.life == 0:
+                ends -= 1
+
+                # tells user that player has lost
+                if self.playermode == "human":
+                    myfont = pygame.font.SysFont("Comic sams", 100)
+                    pygame.font.Font.set_bold
+                    self.screen.blit(myfont.render(" Enemy wins", 1, (194,118,55)), (150, 180))
+
+                self.player.kill() # removes player sprite
+                self.enemy.kill()  # removes enemy sprite
+
+                if self.playermode == "human":
+                    # delays run finalization for human mode
+                    if ends == -self.overturetime:
+                        return return_run()
+                else:
+                    return return_run()
+
+
+            # checks enemy life status
+            if self.enemy.life == 0:
+                ends -= 1
+
+                self.screen.fill((250,250,250))
+                self.tilemap.draw(self.screen)
+
+                # tells user that player has won
+                if self.playermode == "human":
+                    myfont = pygame.font.SysFont("Comic sams", 100)
+                    pygame.font.Font.set_bold
+                    self.screen.blit(myfont.render(" Player wins ", 1, (150,24,25) ), (170, 180))
+
+                self.enemy.kill()   # removes enemy sprite
+                self.player.kill()  # removes player sprite
+
+                if self.playermode == "human":
+                    if ends == -self.overturetime:
+                        return return_run()
+                else:
+                    return return_run()
+
+
+            if self.loadplayer == "no":# removes player sprite from game
+                self.player.kill()
+
+            if self.loadenemy == "no":  #removes enemy sprite from game
+                self.enemy.kill()
+
+                # updates screen
+            pygame.display.flip()
+
+
+            # game runtime limit
+            if self.playermode == 'ai':
+                if self.time >= enemy.timeexpire:
+                    return return_run()
+
+            else:
+                if self.time >= self.timeexpire:
+                    return return_run()
+
+
+
+    # repeats run for every enemy in list
+    def multiple(self,pcont,econt):
+
+        vfitness, vplayerlife, venemylife, vtime = [],[],[],[]
+        for e in self.enemies:
+
+            fitness, playerlife, enemylife, time  = self.run_single(e,pcont,econt)
+            vfitness.append(fitness)
+            vplayerlife.append(playerlife)
+            venemylife.append(enemylife)
+            vtime.append(time)
+
+        vfitness = self.cons_multi(numpy.array(vfitness))
+        vplayerlife = self.cons_multi(numpy.array(vplayerlife))
+        venemylife = self.cons_multi(numpy.array(venemylife))
+        vtime = self.cons_multi(numpy.array(vtime))
+
+        return    vfitness, vplayerlife, venemylife, vtime
+
+
+    # checks objective mode
+    def play(self,pcont="None",econt="None"):
+
+        if self.multiplemode == "yes":
+            return self.multiple(pcont,econt)
+        else:
+            return self.run_single(self.enemies[0],pcont,econt)
Index: NEAT/specialist_controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># the demo_controller file contains standard controller structures for the agents.\r\n# you can overwrite the method 'control' in your own instance of the environment\r\n# and then use a different type of controller if you wish.\r\n# note that the param 'controller' received by 'control' is provided through environment.play(pcont=x)\r\n# 'controller' could contain either weights to be used in the standard controller (or other controller implemented),\r\n# or even a full network structure (ex.: from NEAT).\r\nfrom controller import Controller\r\nimport numpy as np\r\nimport neat\r\nimport os\r\n\r\ndef sigmoid_activation(x):\r\n\treturn 1./(1.+np.exp(-x))\r\n\r\n\r\n# implements controller structure for player\r\nclass NEAT_Controls(Controller):\r\n\tdef __init__(self):\r\n\t\tlocal_dir = os.path.dirname(__file__)\r\n\t\tconfig_file = os.path.join(local_dir, 'config-feedforward.txt')\r\n\t\tconfig = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,\r\n\t\t\t\t\t\t\t\t\tneat.DefaultSpeciesSet, neat.DefaultStagnation,\r\n\t\t\t\t\t\t\t\t\tconfig_file)\r\n\t\tself.config = config\r\n\r\n\tdef control(self, sensor_data, genome):\r\n\t\tnet = neat.nn.FeedForwardNetwork.create(genome, self.config)\r\n\t\toutput = net.activate(sensor_data)\r\n\t\t# takes decisions about sprite actions\r\n\t\tif output[0] > 0.5:\r\n\t\t\tleft = 1\r\n\t\telse:\r\n\t\t\tleft = 0\r\n\r\n\t\tif output[1] > 0.5:\r\n\t\t\tright = 1\r\n\t\telse:\r\n\t\t\tright = 0\r\n\r\n\t\tif output[2] > 0.5:\r\n\t\t\tjump = 1\r\n\t\telse:\r\n\t\t\tjump = 0\r\n\r\n\t\tif output[3] > 0.5:\r\n\t\t\tshoot = 1\r\n\t\telse:\r\n\t\t\tshoot = 0\r\n\r\n\t\tif output[4] > 0.5:\r\n\t\t\trelease = 1\r\n\t\telse:\r\n\t\t\trelease = 0\r\n\r\n\t\treturn [left, right, jump, shoot, release]\r\n\r\n\r\n\r\n# implements controller structure for enemy\r\nclass enemy_controller(Controller):\r\n\tdef __init__(self, _n_hidden):\r\n\t\t# Number of hidden neurons\r\n\t\tself.n_hidden = [_n_hidden]\r\n\r\n\tdef control(self, inputs,controller):\r\n\t\t# Normalises the input using min-max scaling\r\n\t\tinputs = (inputs-min(inputs))/float((max(inputs)-min(inputs)))\r\n\r\n\t\tif self.n_hidden[0]>0:\r\n\t\t\t# Preparing the weights and biases from the controller of layer 1\r\n\r\n\t\t\t# Biases for the n hidden neurons\r\n\t\t\tbias1 = controller[:self.n_hidden[0]].reshape(1,self.n_hidden[0])\r\n\t\t\t# Weights for the connections from the inputs to the hidden nodes\r\n\t\t\tweights1_slice = len(inputs)*self.n_hidden[0] + self.n_hidden[0]\r\n\t\t\tweights1 = controller[self.n_hidden[0]:weights1_slice].reshape((len(inputs),self.n_hidden[0]))\r\n\r\n\t\t\t# Outputs activation first layer.\r\n\t\t\toutput1 = sigmoid_activation(inputs.dot(weights1) + bias1)\r\n\r\n\t\t\t# Preparing the weights and biases from the controller of layer 2\r\n\t\t\tbias2 = controller[weights1_slice:weights1_slice + 5].reshape(1,5)\r\n\t\t\tweights2 = controller[weights1_slice + 5:].reshape((self.n_hidden[0],5))\r\n\r\n\t\t\t# Outputting activated second layer. Each entry in the output is an action\r\n\t\t\toutput = sigmoid_activation(output1.dot(weights2)+ bias2)[0]\r\n\t\telse:\r\n\t\t\tbias = controller[:5].reshape(1, 5)\r\n\t\t\tweights = controller[5:].reshape((len(inputs), 5))\r\n\r\n\t\t\toutput = sigmoid_activation(inputs.dot(weights) + bias)[0]\r\n\r\n\t\t# takes decisions about sprite actions\r\n\t\tif output[0] > 0.5:\r\n\t\t\tattack1 = 1\r\n\t\telse:\r\n\t\t\tattack1 = 0\r\n\r\n\t\tif output[1] > 0.5:\r\n\t\t\tattack2 = 1\r\n\t\telse:\r\n\t\t\tattack2 = 0\r\n\r\n\t\tif output[2] > 0.5:\r\n\t\t\tattack3 = 1\r\n\t\telse:\r\n\t\t\tattack3 = 0\r\n\r\n\t\tif output[3] > 0.5:\r\n\t\t\tattack4 = 1\r\n\t\telse:\r\n\t\t\tattack4 = 0\r\n\r\n\t\treturn [attack1, attack2, attack3, attack4]\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/specialist_controller.py b/NEAT/specialist_controller.py
--- a/NEAT/specialist_controller.py	(revision 41bb8584d54442b48595f32b39c02eba266c9a85)
+++ b/NEAT/specialist_controller.py	(date 1632487473221)
@@ -17,7 +17,7 @@
 class NEAT_Controls(Controller):
 	def __init__(self):
 		local_dir = os.path.dirname(__file__)
-		config_file = os.path.join(local_dir, 'config-feedforward.txt')
+		config_file = os.path.join(local_dir, 'config-feedforward')
 		config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
 									neat.DefaultSpeciesSet, neat.DefaultStagnation,
 									config_file)
Index: NEAT/apply_NEAT.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>################################\r\n# EvoMan FrameWork - V1.0 2016 #\r\n# Author: Karine Miras         #\r\n# karine.smiras@gmail.com      #\r\n################################\r\n\r\n# imports framework\r\nimport sys, os\r\nimport numpy as np\r\nimport neat\r\nimport pandas as pd\r\nsys.path.insert(0, 'evoman')\r\nfrom environment import Environment\r\nfrom specialist_controller import NEAT_Controls\r\n\r\n\r\n\r\n# choose this for not using visuals and thus making experiments faster\r\nheadless = True\r\nif headless:\r\n    os.environ[\"SDL_VIDEODRIVER\"] = \"dummy\"\r\n\r\nname_experiment = 'NEAT_specialist'\r\n\r\n\r\nn_hidden_neurons = 10\r\nenemy = 2                   #which enemy\r\ngenerations = 15            #number of generations per run\r\ntotal_fitness_data = []\r\nchildren_index = []\r\nchildren_data = []\r\nmax_health = 0\r\ngeneration = 0\r\n# initializes simulation in individual evolution mode, for single static enemy.\r\nenv = Environment(experiment_name=name_experiment,\r\n                  enemies=[enemy],\r\n                  playermode=\"ai\",\r\n                  player_controller=NEAT_Controls(),\r\n                  enemymode=\"static\",\r\n                  level=2,\r\n                  speed=\"fastest\",\r\n                  randomini = \"yes\")\r\n\r\n# default environment fitness is assumed for experiment\r\nenv.state_to_log()  # checks environment state\r\n\r\n\r\n# runs simulation\r\n\r\n\r\n\r\ndef eval_genomes(genomes, config):\r\n    fitness_array = []\r\n    fitness_array_smop = []\r\n    global generation\r\n    generation += 1\r\n    for genome_id, genome in genomes:\r\n        genome.fitness = 0\r\n\r\n        f, p, e, t = env.play(pcont=genome)\r\n\r\n        fitness_new = 0.9 * (100 - e) + 0.1 * p - np.log(t)\r\n        fitness_smop = (100 / (100 - (0.9 * (100 - e) + 0.1 * p - np.log10(t))))\r\n\r\n        children_index.append([generation, f, p, e, t])\r\n        #children_data.append(genome)\r\n\r\n        fitness_array.append(fitness_new)\r\n        fitness_array_smop.append(fitness_smop)\r\n\r\n        genome.fitness = fitness_new\r\n\r\n    total_fitness_data.append([np.max(fitness_array),\r\n                               np.mean(fitness_array),\r\n                               np.std(fitness_array)])\r\n\r\n\r\n\r\ndef run(config_file, run, experiment_name):\r\n    \"\"\"\r\n    runs the NEAT algorithm to train a neural network to play mega man.\r\n    It uses the config file named config-feedforward.txt. After running it stores it results in CSV files.\r\n    \"\"\"\r\n\r\n    config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,\r\n                                neat.DefaultSpeciesSet, neat.DefaultStagnation,\r\n                                config_file)\r\n\r\n    # Create the population\r\n    p = neat.Population(config)\r\n\r\n    # Add a stdout reporter to show progress in the terminal.\r\n    p.add_reporter(neat.StdOutReporter(True))\r\n    stats = neat.StatisticsReporter()\r\n    p.add_reporter(stats)\r\n    #p.add_reporter(neat.Checkpointer(5))\r\n\r\n    # Run for up to generations generations.\r\n    winner = p.run(eval_genomes, generations)\r\n\r\n    # show final stats\r\n    print('\\nBest genome:\\n{!s}'.format(winner))\r\n\r\n    # stats to csv\r\n\r\n    total_fitness_data_df = pd.DataFrame(total_fitness_data, columns = [\"max\", \"mean\", \"std_dev\"])\r\n    total_fitness_data_df.to_csv(f'{experiment_name}/fitness_data_{run}.csv', index = False)\r\n\r\n    children_index_df = pd.DataFrame(children_index, columns = ['generation', 'fitness', 'p_health',\r\n                         'e_health', 'time'])\r\n    children_index_df.to_csv(f'{experiment_name}/full_data_index_{run}.csv', index = False)\r\n\r\n    # children_data_df = pd.DataFrame(children_data)\r\n    # children_data_df.to_csv(f'{experiment_name}/full_data_{run}.csv', index = False)\r\n\r\n    total_fitness_data.clear()\r\n    children_index.clear()\r\n    children_data.clear()\r\n    global generation\r\n    generation = 0\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/apply_NEAT.py b/NEAT/apply_NEAT.py
--- a/NEAT/apply_NEAT.py	(revision 41bb8584d54442b48595f32b39c02eba266c9a85)
+++ b/NEAT/apply_NEAT.py	(date 1632487473221)
@@ -20,29 +20,11 @@
 if headless:
     os.environ["SDL_VIDEODRIVER"] = "dummy"
 
-name_experiment = 'NEAT_specialist'
+
 
 
-n_hidden_neurons = 10
-enemy = 2                   #which enemy
-generations = 15            #number of generations per run
-total_fitness_data = []
-children_index = []
-children_data = []
-max_health = 0
-generation = 0
-# initializes simulation in individual evolution mode, for single static enemy.
-env = Environment(experiment_name=name_experiment,
-                  enemies=[enemy],
-                  playermode="ai",
-                  player_controller=NEAT_Controls(),
-                  enemymode="static",
-                  level=2,
-                  speed="fastest",
-                  randomini = "yes")
 
-# default environment fitness is assumed for experiment
-env.state_to_log()  # checks environment state
+
 
 
 # runs simulation
@@ -76,11 +58,23 @@
 
 
 
-def run(config_file, run, experiment_name):
+def run(environment, generations, config_file, run, experiment_name):
     """
     runs the NEAT algorithm to train a neural network to play mega man.
     It uses the config file named config-feedforward.txt. After running it stores it results in CSV files.
     """
+    global env
+    global total_fitness_data
+    global children_index
+    global children_data
+    global generation
+
+    env = environment
+    total_fitness_data = []
+    children_index = []
+    children_data = []
+    generation = 0
+
 
     config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
                                 neat.DefaultSpeciesSet, neat.DefaultStagnation,
@@ -102,7 +96,6 @@
     print('\nBest genome:\n{!s}'.format(winner))
 
     # stats to csv
-
     total_fitness_data_df = pd.DataFrame(total_fitness_data, columns = ["max", "mean", "std_dev"])
     total_fitness_data_df.to_csv(f'{experiment_name}/fitness_data_{run}.csv', index = False)
 
@@ -113,8 +106,3 @@
     # children_data_df = pd.DataFrame(children_data)
     # children_data_df.to_csv(f'{experiment_name}/full_data_{run}.csv', index = False)
 
-    total_fitness_data.clear()
-    children_index.clear()
-    children_data.clear()
-    global generation
-    generation = 0
Index: NEAT/evoman/environment_draw.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/environment_draw.py b/NEAT/evoman/environment_draw.py
new file mode 100644
--- /dev/null	(date 1632487473252)
+++ b/NEAT/evoman/environment_draw.py	(date 1632487473252)
@@ -0,0 +1,606 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import gzip
+import pickle
+import numpy
+import pygame
+from pygame.locals import *
+import struct
+import tmx
+
+from player import *
+from controller import Controller
+
+
+# main class
+class Environment(object):
+
+
+    # simulation parameters
+    def __init__(self,
+                 experiment_name='test',
+                 multiplemode="no",           # yes or no
+                 enemies=[1],                 # array with 1 to 8 items, values from 1 to 8
+                 loadplayer="yes",            # yes or no
+                 loadenemy="yes",             # yes or no
+                 level=2,                     # integer
+                 playermode="ai",             # ai or human
+                 enemymode="static",          # ai or static
+                 speed="fastest",             # normal or fastest
+                 inputscoded="no",            # yes or no
+                 randomini="no",              # yes or no
+                 sound="off",                  # on or off
+                 contacthurt="player",        # player or enemy
+                 logs="on",                   # on or off
+                 savelogs="yes",              # yes or no
+                 clockprec="low",
+                 timeexpire=3000,             # integer
+                 overturetime=100,            # integer
+                 solutions=None,              # any
+                 fullscreen=False,            # True or False
+                 player_controller=None,      # controller object
+                 enemy_controller=None,      # controller object
+                 use_joystick=False):
+
+
+        # initializes parameters
+
+        self.experiment_name = experiment_name
+        self.multiplemode = multiplemode
+        self.enemies = enemies
+        self.enemyn = enemies[0] # initial current enemy
+        self.loadplayer = loadplayer
+        self.loadenemy = loadenemy
+        self.level = level
+        self.playermode = playermode
+        self.enemymode = enemymode
+        self.speed = speed
+        self.inputscoded = inputscoded
+        self.randomini = randomini
+        self.sound = sound
+        self.contacthurt = contacthurt
+        self.logs = logs
+        self.fullscreen = fullscreen
+        self.savelogs = savelogs
+        self.clockprec = clockprec
+        self.timeexpire = timeexpire
+        self.overturetime = overturetime
+        self.solutions = solutions
+        self.joy = 0
+        self.use_joystick = use_joystick
+
+
+        # initializes default random controllers
+
+        if self.playermode == "ai" and player_controller == None:
+            self.player_controller = Controller()
+        else:
+            self.player_controller =  player_controller
+
+        if self.enemymode == "ai" and enemy_controller == None:
+            self.enemy_controller = Controller()
+        else:
+            self.enemy_controller =  enemy_controller
+
+
+        # initializes log file
+        if self.logs  == "on" and self.savelogs == "yes":
+            file_aux  = open(self.experiment_name+'/evoman_logs.txt','w')
+            file_aux.close()
+
+
+        # initializes pygame library
+        pygame.init()
+        self.print_logs("MESSAGE: Pygame initialized for simulation.")
+
+        # initializes sound library for playing mode
+        if self.sound == "on":
+            pygame.mixer.init()
+            self.print_logs("MESSAGE: sound has been turned on.")
+
+        # initializes joystick library
+        if self.use_joystick:
+            pygame.joystick.init()
+            self.joy = pygame.joystick.get_count()
+
+        self.clock = pygame.time.Clock() # initializes game clock resource
+        
+        if self.fullscreen:
+            flags =  DOUBLEBUF  |  FULLSCREEN
+        else:
+            flags =  DOUBLEBUF
+
+        self.screen = pygame.display.set_mode((736, 512), flags)
+
+        self.screen.set_alpha(None) # disables uneeded alpha
+        pygame.event.set_allowed([QUIT, KEYDOWN, KEYUP]) # enables only needed events
+
+        self.load_sprites()
+
+
+
+    def load_sprites(self):
+
+        # loads enemy and map
+        enemy = __import__('enemy'+str(self.enemyn))
+        self.tilemap = tmx.load(enemy.tilemap, self.screen.get_size())  # map
+
+        self.sprite_e = tmx.SpriteLayer()
+        start_cell = self.tilemap.layers['triggers'].find('enemy')[0]
+        self.enemy = enemy.Enemy((start_cell.px, start_cell.py), self.sprite_e)
+        self.tilemap.layers.append(self.sprite_e)  # enemy
+
+        # loads player
+        self.sprite_p = tmx.SpriteLayer()
+        start_cell = self.tilemap.layers['triggers'].find('player')[0]
+        self.player = Player((start_cell.px, start_cell.py), self.enemyn, self.level, self.sprite_p)
+        self.tilemap.layers.append(self.sprite_p)
+
+        self.player.sensors = Sensors()
+        self.enemy.sensors = Sensors()
+
+
+    # updates environment with backup of current solutions in simulation
+    def get_solutions(self):
+        return self.solutions
+
+
+        # method for updating solutions bkp in simulation
+    def update_solutions(self, solutions):
+        self.solutions = solutions
+
+
+    # method for updating simulation parameters
+    def update_parameter(self, name, value):
+
+        if type(value) is str:
+            exec('self.'+name +"= '"+ value+"'")
+        else:
+            exec('self.'+name +"= "+ str(value))
+
+        self.print_logs("PARAMETER CHANGE: "+name+" = "+str(value))
+
+
+
+    def print_logs(self, msg):
+        if self.logs == "on":
+            print('\n'+msg) # prints log messages to screen
+
+            if self.savelogs == "yes": # prints log messages to file
+                file_aux  = open(self.experiment_name+'/evoman_logs.txt','a')
+                file_aux.write('\n\n'+msg)
+                file_aux.close()
+
+
+    def get_num_sensors(self):
+
+        if hasattr(self, 'enemy') and self.enemymode == "ai":
+            return  len(self.enemy.sensors.get(self))
+        else:
+            if hasattr(self, 'player') and self.playermode == "ai":
+                return len(self.player.sensors.get(self))
+            else:
+                return 0
+
+
+    # writes all variables related to game state into log
+    def state_to_log(self):
+
+
+        self.print_logs("########## Simulation state - INI ###########")
+        if self.solutions == None:
+            self.print_logs("# solutions # : EMPTY ")
+        else:
+            self.print_logs("# solutions # : LOADED ")
+
+        self.print_logs("# sensors # : "+ str( self.get_num_sensors() ))
+        self.print_logs(" ------  parameters ------  ")
+        self.print_logs("# contact hurt (training agent) # : "  +self.contacthurt)
+
+        self.print_logs("multiple mode: "+self.multiplemode)
+
+        en = ''
+        for e in self.enemies:
+            en += ' '+str(e)
+        self.print_logs("enemies list:"+ en)
+
+        self.print_logs("current enemy: " +str(self.enemyn))
+        self.print_logs("player mode: " +self.playermode)
+        self.print_logs("enemy mode: "  +self.enemymode)
+        self.print_logs("level: " +str(self.level))
+        self.print_logs("clock precision: "+ self.clockprec)
+        self.print_logs("inputs coded: "  +self.inputscoded)
+        self.print_logs("random initialization: "  +self.randomini)
+        self.print_logs("expiration time: "  +str(self.timeexpire))
+        self.print_logs("speed: " +self.speed)
+        self.print_logs("load player: " +self.loadplayer)
+        self.print_logs("load enemy: " +self.loadenemy)
+        self.print_logs("sound: "  +self.sound)
+        self.print_logs("overture time: "  +str(self.overturetime))
+        self.print_logs("logs: "+self.logs)
+        self.print_logs("save logs: "+self.savelogs)
+        self.print_logs("########## Simulation state - END ###########")
+
+
+
+    # exports current environment state to files
+    def save_state(self):
+
+        # saves configuration file for simulation parameters
+        file_aux  = open(self.experiment_name+'/evoman_paramstate.txt','w')
+        en = ''
+        for e in self.enemies:
+            en += ' '+str(e)
+        file_aux.write("\nenemies"+ en)
+        file_aux.write("\ntimeexpire "  +str(self.timeexpire))
+        file_aux.write("\nlevel " +str(self.level))
+        file_aux.write("\nenemyn " +str(self.enemyn))
+        file_aux.write("\noverturetime "  +str(self.overturetime))
+        file_aux.write("\nplayermode " +self.playermode)
+        file_aux.write("\nenemymode "  +self.enemymode)
+        file_aux.write("\ncontacthurt "  +self.contacthurt)
+        file_aux.write("\nclockprec "+ self.clockprec)
+        file_aux.write("\ninputscoded "  +self.inputscoded)
+        file_aux.write("\nrandomini "  +self.randomini)
+        file_aux.write("\nmultiplemode "+self.multiplemode)
+        file_aux.write("\nspeed " +self.speed)
+        file_aux.write("\nloadplayer " +self.loadplayer)
+        file_aux.write("\nloadenemy " +self.loadenemy)
+        file_aux.write("\nsound "  +self.sound)
+        file_aux.write("\nlogs "+self.logs)
+        file_aux.write("\nsavelogs "+self.savelogs)
+        file_aux.close()
+
+        # saves state of solutions in the simulation
+        file = gzip.open(self.experiment_name+'/evoman_solstate', 'w', compresslevel = 5)
+        pickle.dump(self.solutions, file, protocol=2)
+        file.close()
+
+
+        self.print_logs("MESSAGE: state has been saved to files.")
+
+
+
+    # loads a state for environment from files
+    def load_state(self):
+
+
+        try:
+
+            # loads parameters
+            state = open(self.experiment_name+'/evoman_paramstate.txt','r')
+            state = state.readlines()
+            for idp,p in enumerate(state):
+                pv = p.split(' ')
+
+                if idp>0:    # ignore first line
+                    if idp==1: # enemy list
+                        en = []
+                        for i in range(1,len(pv)):
+                            en.append(int(pv[i].rstrip('\n')))
+                        self.update_parameter(pv[0], en)
+                    elif idp<6: # numeric params
+                        self.update_parameter(pv[0], int(pv[1].rstrip('\n')))
+                    else: # string params
+                        self.update_parameter(pv[0], pv[1].rstrip('\n'))
+
+            # loads solutions
+            file = gzip.open(self.experiment_name+'/evoman_solstate')
+            self.solutions =  pickle.load(file, encoding='latin1')
+            self.print_logs("MESSAGE: state has been loaded.")
+
+        except IOError:
+            self.print_logs("ERROR: could not load state.")
+
+
+
+
+    def checks_params(self):
+
+        # validates parameters values
+
+        if self.multiplemode == "yes" and len(self.enemies) < 2:
+            self.print_logs("ERROR: 'enemies' must contain more than one enemy for multiple mode.")
+            sys.exit(0)
+
+        if self.enemymode not in ('static','ai'):
+            self.print_logs("ERROR: 'enemy mode' must be 'static' or 'ai'.")
+            sys.exit(0)
+
+        if self.playermode not in ('human','ai'):
+            self.print_logs("ERROR: 'player mode' must be 'human' or 'ai'.")
+            sys.exit(0)
+
+        if self.loadplayer not in ('yes','no'):
+            self.print_logs("ERROR: 'load player' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.loadenemy not in ('yes','no'):
+            self.print_logs("ERROR: 'load enemy' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.inputscoded not in ('yes','no'):
+            self.print_logs("ERROR: 'inputs coded' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.multiplemode not in ('yes','no'):
+            self.print_logs("ERROR: 'multiplemode' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.randomini not in ('yes','no'):
+            self.print_logs("ERROR: 'random ini' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.savelogs not in ('yes','no'):
+            self.print_logs("ERROR: 'save logs' value must be 'yes' or 'no'.")
+            sys.exit(0)
+
+        if self.speed not in ('normal','fastest'):
+            self.print_logs("ERROR: 'speed' value must be 'normal' or 'fastest'.")
+            sys.exit(0)
+
+        if self.logs not in ('on','off'):
+            self.print_logs("ERROR: 'logs' value must be 'on' or 'off'.")
+            sys.exit(0)
+
+        if self.clockprec not in ('low','medium'):
+            self.print_logs("ERROR: 'clockprec' value must be 'low' or 'medium'.")
+            sys.exit(0)
+
+        if self.sound not in ('on','off'):
+            self.print_logs("ERROR: 'sound' value must be 'on' or 'off'.")
+            sys.exit(0)
+
+        if self.contacthurt not in ('player','enemy'):
+            self.print_logs("ERROR: 'contacthurt' value must be 'player' or 'enemy'.")
+            sys.exit(0)
+
+        if type(self.timeexpire) is not int:
+            self.print_logs("ERROR: 'timeexpire' must be integer.")
+            sys.exit(0)
+
+        if type(self.level) is not int:
+            self.print_logs("ERROR: 'level' must be integer.")
+            sys.exit(0)
+
+        if type(self.overturetime) is not int:
+            self.print_logs("ERROR: 'overturetime' must be integer.")
+            sys.exit(0)
+
+
+        # checks parameters consistency
+
+        if self.multiplemode == "no" and len(self.enemies) > 1:
+            self.print_logs("MESSAGE: there is more than one enemy in 'enemies' list although the mode is not multiple.")
+
+        if self.level < 1 or self.level > 3:
+            self.print_logs("MESSAGE: 'level' chosen is out of recommended (tested).")
+
+
+
+
+            # default fitness function for single solutions
+    def fitness_single(self):
+        return (100/(100-(0.9*(100 - self.get_enemylife()) + 0.1*self.get_playerlife() - numpy.log10(self.get_time()))))
+
+    # default fitness function for consolidating solutions among multiple games
+    def cons_multi(self,values):
+        return values.mean() - values.std()
+
+    # measures the energy of the player
+    def get_playerlife(self):
+        return self.player.life
+
+    # measures the energy of the enemy
+    def get_enemylife(self):
+        return self.enemy.life
+
+    # gets run time
+    def get_time(self):
+        return self.time
+
+
+    # runs game for a single enemy
+    def run_single(self,enemyn,pcont,econt):
+
+        # sets controllers
+        self.pcont = pcont
+        self.econt = econt
+
+        self.checks_params()
+
+
+        self.enemyn = enemyn # sets the current enemy
+        ends = 0
+        self.time = 0
+        self.freeze_p = False
+        self.freeze_e = False
+        self.start = False
+
+        enemy = __import__('enemy'+str(self.enemyn))
+
+        self.load_sprites()
+
+
+        # game main loop
+
+        while 1:
+
+            # adjusts frames rate for defining game speed
+
+            if self.clockprec == "medium":  # medium clock precision
+                if self.speed == 'normal':
+                    self.clock.tick_busy_loop(30)
+                elif self.speed == 'fastest':
+                    self.clock.tick_busy_loop()
+
+            else:   # low clock precision
+
+                if self.speed == 'normal':
+                    self.clock.tick(30)
+                elif self.speed == 'fastest':
+                    self.clock.tick()
+
+
+            # game timer
+            self.time += 1
+            if self.playermode == "human" or self.sound == "on":
+                # sound effects
+                if self.sound == "on" and self.time == 1:
+                    sound = pygame.mixer.Sound('evoman/sounds/open.wav')
+                    c = pygame.mixer.Channel(1)
+                    c.set_volume(1)
+                    c.play(sound,loops=10)
+
+                if self.time > self.overturetime: # delays game start a little bit for human mode
+                    self.start = True
+            else:
+                self.start = True
+
+
+            # checks screen closing button
+            self.event = pygame.event.get()
+            for event in  self.event:
+                if event.type == pygame.QUIT:
+                    return
+                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                    return
+
+            # updates objects and draws its itens on screen
+            self.screen.fill((250,250,250))
+            self.tilemap.update( 33 / 1000., self)
+            self.tilemap.draw(self.screen)
+
+            # player life bar
+            vbar = int(100 *( 1-(self.player.life/float(self.player.max_life)) ))
+            pygame.draw.line(self.screen, (0,   0,   0), [40, 40],[140, 40], 2)
+            pygame.draw.line(self.screen, (0,   0,   0), [40, 45],[140, 45], 5)
+            pygame.draw.line(self.screen, (150,24,25),   [40, 45],[140 - vbar, 45], 5)
+            pygame.draw.line(self.screen, (0,   0,   0), [40, 49],[140, 49], 2)
+
+            # enemy life bar
+            vbar = int(100 *( 1-(self.enemy.life/float(self.enemy.max_life)) ))
+            pygame.draw.line(self.screen, (0,   0,   0), [590, 40],[695, 40], 2)
+            pygame.draw.line(self.screen, (0,   0,   0), [590, 45],[695, 45], 5)
+            pygame.draw.line(self.screen, (194,118,55),  [590, 45],[695 - vbar, 45], 5)
+            pygame.draw.line(self.screen, (0,   0,   0), [590, 49],[695, 49], 2)
+
+
+            #gets fitness for training agents
+            fitness = self.fitness_single()
+
+
+            # returns results of the run
+            def return_run():
+                self.print_logs("RUN: run status: enemy: "+str(self.enemyn)+"; fitness: " + str(fitness) + "; player life: " + str(self.player.life)  + "; enemy life: " + str(self.enemy.life) + "; time: " + str(self.time))
+
+                return  fitness, self.player.life, self.enemy.life, self.time
+
+
+
+            if self.start == False and self.playermode == "human":
+
+                myfont = pygame.font.SysFont("Comic sams", 100)
+                pygame.font.Font.set_bold
+                self.screen.blit(myfont.render("Player", 1,  (150,24,25)), (50, 180))
+                self.screen.blit(myfont.render("  VS  ", 1,  (50,24,25)), (250, 180))
+                self.screen.blit(myfont.render("Enemy "+str(self.enemyn), 1,  (194,118,55)), (400, 180))
+
+
+            # checks player life status
+            if self.player.life == 0:
+                ends -= 1
+
+                # tells user that player has lost
+                if self.playermode == "human":
+                    myfont = pygame.font.SysFont("Comic sams", 100)
+                    pygame.font.Font.set_bold
+                    self.screen.blit(myfont.render(" Enemy wins", 1, (194,118,55)), (150, 180))
+
+                self.player.kill() # removes player sprite
+                self.enemy.kill()  # removes enemy sprite
+
+                if self.playermode == "human":
+                    # delays run finalization for human mode
+                    if ends == -self.overturetime:
+                        return return_run()
+                else:
+                    return return_run()
+
+
+            # checks enemy life status
+            if self.enemy.life == 0:
+                ends -= 1
+
+                self.screen.fill((250,250,250))
+                self.tilemap.draw(self.screen)
+
+                # tells user that player has won
+                if self.playermode == "human":
+                    myfont = pygame.font.SysFont("Comic sams", 100)
+                    pygame.font.Font.set_bold
+                    self.screen.blit(myfont.render(" Player wins ", 1, (150,24,25) ), (170, 180))
+
+                self.enemy.kill()   # removes enemy sprite
+                self.player.kill()  # removes player sprite
+
+                if self.playermode == "human":
+                    if ends == -self.overturetime:
+                        return return_run()
+                else:
+                    return return_run()
+
+
+            if self.loadplayer == "no":# removes player sprite from game
+                self.player.kill()
+
+            if self.loadenemy == "no":  #removes enemy sprite from game
+                self.enemy.kill()
+
+                # updates screen
+            pygame.display.flip()
+
+
+            # game runtime limit
+            if self.playermode == 'ai':
+                if self.time >= enemy.timeexpire:
+                    return return_run()
+
+            else:
+                if self.time >= self.timeexpire:
+                    return return_run()
+
+
+
+    # repeats run for every enemy in list
+    def multiple(self,pcont,econt):
+
+        vfitness, vplayerlife, venemylife, vtime = [],[],[],[]
+        for e in self.enemies:
+
+            fitness, playerlife, enemylife, time  = self.run_single(e,pcont,econt)
+            vfitness.append(fitness)
+            vplayerlife.append(playerlife)
+            venemylife.append(enemylife)
+            vtime.append(time)
+
+        vfitness = self.cons_multi(numpy.array(vfitness))
+        vplayerlife = self.cons_multi(numpy.array(vplayerlife))
+        venemylife = self.cons_multi(numpy.array(venemylife))
+        vtime = self.cons_multi(numpy.array(vtime))
+
+        return    vfitness, vplayerlife, venemylife, vtime
+
+
+    # checks objective mode
+    def play(self,pcont="None",econt="None"):
+
+        if self.multiplemode == "yes":
+            return self.multiple(pcont,econt)
+        else:
+            return self.run_single(self.enemies[0],pcont,econt)
Index: NEAT/config_main.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/config_main.yml b/NEAT/config_main.yml
new file mode 100644
--- /dev/null	(date 1632733171985)
+++ b/NEAT/config_main.yml	(date 1632733171985)
@@ -0,0 +1,34 @@
+decision_variables:
+    name_experiment: tune_parameters
+    tune_parameters: True
+    apply_optimization: False
+    show_figures: True
+    save_figures: False
+
+experiment_parameters:
+    number_of_runs: 5
+    enemy: 2
+    generations: 3
+
+
+tuning_parameters:
+# choose a number of  tuning parameters and define the type of the parameter (integer, float, string).
+    tuning_parameter_1:
+        name: max_stagnation
+        type: integer
+        l_bound: 2
+        u_bound: 4
+        num_variations: 3
+    tuning_parameter_2:
+        name: weight_mutate_rate
+        type: float
+        l_bound: 0.7
+        u_bound: 0.9
+        num_variations: 3
+    tuning_parameter_3:
+        name: bias_mutate_rate
+        type: float
+        l_bound: 0.7
+        u_bound: 0.9
+        num_variations: 3
+
Index: NEAT/evoman/Base/SpriteConstants.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/Base/SpriteConstants.py b/NEAT/evoman/Base/SpriteConstants.py
new file mode 100644
--- /dev/null	(date 1632487473268)
+++ b/NEAT/evoman/Base/SpriteConstants.py	(date 1632487473268)
@@ -0,0 +1,22 @@
+
+#Colors
+BLACK = (0, 0, 0)
+
+#Directions
+RIGHT = 1
+LEFT = 0
+
+#Movements types
+STANDING = 0
+
+START_RUNNING = 1
+
+RUNNING_STEP1 = 2
+RUNNING_STEP2 = 3
+
+JUMPING = 4
+
+SHOOTING = 6
+SHOOTING_JUMPING = 5
+
+HURTING = 7
Index: NEAT/config-feedforward
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n[NEAT]\r\nfitness_criterion     = max\r\nfitness_threshold     = 100\r\npop_size              = 20\r\nreset_on_extinction   = False\r\n\r\n[DefaultGenome]\r\n# node activation options\r\nactivation_default      = sigmoid\r\nactivation_mutate_rate  = 0.0\r\nactivation_options      = sigmoid\r\n\r\n# node aggregation options\r\naggregation_default     = sum\r\naggregation_mutate_rate = 0.0\r\naggregation_options     = sum\r\n\r\n# node bias options\r\nbias_init_mean          = 0.0\r\nbias_init_stdev         = 1.0\r\nbias_max_value          = 1.0\r\nbias_min_value          = -1.0\r\nbias_mutate_power       = 0.05\r\nbias_mutate_rate        = 0.8\r\nbias_replace_rate       = 0.1\r\n\r\n# genome compatibility options\r\ncompatibility_disjoint_coefficient = 1.0\r\ncompatibility_weight_coefficient   = 0.5\r\n\r\n# connection add/remove rates\r\nconn_add_prob           = 0.5\r\nconn_delete_prob        = 0.5\r\n\r\n# connection enable options\r\nenabled_default         = True\r\nenabled_mutate_rate     = 0.01\r\n\r\nfeed_forward            = True\r\ninitial_connection      = full_nodirect\r\n\r\n# node add/remove rates\r\nnode_add_prob           = 0.2\r\nnode_delete_prob        = 0.2\r\n\r\n# network parameters\r\nnum_hidden              = 1\r\nnum_inputs              = 20\r\nnum_outputs             = 6\r\n\r\n# node response options\r\nresponse_init_mean      = 1.0\r\nresponse_init_stdev     = 0.0\r\nresponse_max_value      = 1.0\r\nresponse_min_value      = -1.0\r\nresponse_mutate_power   = 0.0\r\nresponse_mutate_rate    = 0.0\r\nresponse_replace_rate   = 0.0\r\n\r\n# connection weight options\r\nweight_init_mean        = 0.0\r\nweight_init_stdev       = 1.0\r\nweight_max_value        = 1\r\nweight_min_value        = -1\r\nweight_mutate_power     = 0.05\r\nweight_mutate_rate      = 0.8\r\nweight_replace_rate     = 0.1\r\n\r\n[DefaultSpeciesSet]\r\ncompatibility_threshold = 3.0\r\n\r\n[DefaultStagnation]\r\nspecies_fitness_func = max\r\nmax_stagnation       = 4\r\nspecies_elitism      = 2\r\n\r\n[DefaultReproduction]\r\nelitism            = 2\r\nsurvival_threshold = 0.2\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/config-feedforward b/NEAT/config-feedforward
--- a/NEAT/config-feedforward	(revision 41bb8584d54442b48595f32b39c02eba266c9a85)
+++ b/NEAT/config-feedforward	(date 1632593872018)
@@ -2,7 +2,7 @@
 [NEAT]
 fitness_criterion     = max
 fitness_threshold     = 100
-pop_size              = 20
+pop_size              = 100
 reset_on_extinction   = False
 
 [DefaultGenome]
@@ -22,7 +22,7 @@
 bias_max_value          = 1.0
 bias_min_value          = -1.0
 bias_mutate_power       = 0.05
-bias_mutate_rate        = 0.8
+bias_mutate_rate        = 0.7
 bias_replace_rate       = 0.1
 
 # genome compatibility options
@@ -45,9 +45,9 @@
 node_delete_prob        = 0.2
 
 # network parameters
-num_hidden              = 1
+num_hidden              = 10
 num_inputs              = 20
-num_outputs             = 6
+num_outputs             = 5
 
 # node response options
 response_init_mean      = 1.0
@@ -64,7 +64,7 @@
 weight_max_value        = 1
 weight_min_value        = -1
 weight_mutate_power     = 0.05
-weight_mutate_rate      = 0.8
+weight_mutate_rate      = 0.7
 weight_replace_rate     = 0.1
 
 [DefaultSpeciesSet]
@@ -72,7 +72,7 @@
 
 [DefaultStagnation]
 species_fitness_func = max
-max_stagnation       = 4
+max_stagnation       = 2
 species_elitism      = 2
 
 [DefaultReproduction]
Index: NEAT/evoman/Base/SpriteDefinition.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/Base/SpriteDefinition.py b/NEAT/evoman/Base/SpriteDefinition.py
new file mode 100644
--- /dev/null	(date 1632487473268)
+++ b/NEAT/evoman/Base/SpriteDefinition.py	(date 1632487473268)
@@ -0,0 +1,29 @@
+import pygame
+from . import SpriteConstants
+
+class SpriteDefinition(object):
+    """Contains the properties and methods to control a SpriteSheet structure"""
+
+    def __init__(self, fileName, origin_X, origin_Y, width, height):
+        self.SpriteSheet = pygame.image.load(fileName).convert()
+        self.Origin_X = origin_X
+        self.Origin_Y = origin_Y
+        self.Width = width
+        self.Height = height
+
+    def getImage(self, steps_X, steps_Y):
+        marginX = self.Width * steps_X
+        marginY = self.Height * steps_Y
+
+        image = pygame.Surface([self.Width, self.Height]).convert()
+
+        image.blit(self.SpriteSheet,
+                   (0, 0),
+                   (marginX,
+                    marginY,
+                    self.Width,
+                    self.Height))
+
+        image.set_colorkey(SpriteConstants.BLACK)
+
+        return image
Index: NEAT/apply_NEAT_old.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/apply_NEAT_old.py b/NEAT/apply_NEAT_old.py
new file mode 100644
--- /dev/null	(date 1632487473268)
+++ b/NEAT/apply_NEAT_old.py	(date 1632487473268)
@@ -0,0 +1,120 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+# imports framework
+import sys, os
+import numpy as np
+import neat
+import pandas as pd
+sys.path.insert(0, 'evoman')
+from environment import Environment
+from specialist_controller import NEAT_Controls
+
+
+
+# choose this for not using visuals and thus making experiments faster
+headless = True
+if headless:
+    os.environ["SDL_VIDEODRIVER"] = "dummy"
+
+name_experiment = 'NEAT_specialist'
+
+
+n_hidden_neurons = 10
+enemy = 2                   #which enemy
+generations = 15            #number of generations per run
+total_fitness_data = []
+children_index = []
+children_data = []
+max_health = 0
+generation = 0
+# initializes simulation in individual evolution mode, for single static enemy.
+env = Environment(experiment_name=name_experiment,
+                  enemies=[enemy],
+                  playermode="ai",
+                  player_controller=NEAT_Controls(),
+                  enemymode="static",
+                  level=2,
+                  speed="fastest",
+                  randomini = "yes")
+
+# default environment fitness is assumed for experiment
+env.state_to_log()  # checks environment state
+
+
+# runs simulation
+
+
+
+def eval_genomes(genomes, config):
+    fitness_array = []
+    fitness_array_smop = []
+    global generation
+    generation += 1
+    for genome_id, genome in genomes:
+        genome.fitness = 0
+
+        f, p, e, t = env.play(pcont=genome)
+
+        fitness_new = 0.9 * (100 - e) + 0.1 * p - np.log(t)
+        fitness_smop = (100 / (100 - (0.9 * (100 - e) + 0.1 * p - np.log10(t))))
+
+        children_index.append([generation, f, p, e, t])
+        #children_data.append(genome)
+
+        fitness_array.append(fitness_new)
+        fitness_array_smop.append(fitness_smop)
+
+        genome.fitness = fitness_new
+
+    total_fitness_data.append([np.max(fitness_array),
+                               np.mean(fitness_array),
+                               np.std(fitness_array)])
+
+
+
+def run(config_file, run, experiment_name):
+    """
+    runs the NEAT algorithm to train a neural network to play mega man.
+    It uses the config file named config-feedforward.txt. After running it stores it results in CSV files.
+    """
+
+    config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
+                                neat.DefaultSpeciesSet, neat.DefaultStagnation,
+                                config_file)
+
+    # Create the population
+    p = neat.Population(config)
+
+    # Add a stdout reporter to show progress in the terminal.
+    p.add_reporter(neat.StdOutReporter(True))
+    stats = neat.StatisticsReporter()
+    p.add_reporter(stats)
+    #p.add_reporter(neat.Checkpointer(5))
+
+    # Run for up to generations generations.
+    winner = p.run(eval_genomes, generations)
+
+    # show final stats
+    print('\nBest genome:\n{!s}'.format(winner))
+
+    # stats to csv
+
+    total_fitness_data_df = pd.DataFrame(total_fitness_data, columns = ["max", "mean", "std_dev"])
+    total_fitness_data_df.to_csv(f'{experiment_name}/fitness_data_{run}.csv', index = False)
+
+    children_index_df = pd.DataFrame(children_index, columns = ['generation', 'fitness', 'p_health',
+                         'e_health', 'time'])
+    children_index_df.to_csv(f'{experiment_name}/full_data_index_{run}.csv', index = False)
+
+    # children_data_df = pd.DataFrame(children_data)
+    # children_data_df.to_csv(f'{experiment_name}/full_data_{run}.csv', index = False)
+
+    total_fitness_data.clear()
+    children_index.clear()
+    children_data.clear()
+    global generation
+    generation = 0
Index: NEAT/evoman/tmx.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/tmx.py b/NEAT/evoman/tmx.py
new file mode 100644
--- /dev/null	(date 1632487473284)
+++ b/NEAT/evoman/tmx.py	(date 1632487473284)
@@ -0,0 +1,854 @@
+# "Tiled" TMX loader/renderer and more
+# Copyright 2012 Richard Jones <richard@mechanicalcat.net>
+# This code is placed in the Public Domain.
+# 
+# Changes (July 2013 by Renfred Harper):
+# Ported to Python 3
+# Added selective area support SpriteLayer.draw
+
+import sys
+import struct
+import pygame
+from pygame.locals import *
+from pygame import Rect
+from xml.etree import ElementTree
+from base64 import b64decode
+from zlib import decompress
+
+
+class Tile(object):
+    def __init__(self, gid, surface, tileset):
+        self.gid = gid
+        self.surface = surface
+        self.tile_width = tileset.tile_width
+        self.tile_height = tileset.tile_height
+        self.properties = {}
+
+    @classmethod
+    def fromSurface(cls, surface):
+        '''Create a new Tile object straight from a pygame Surface.
+
+        Its tile_width and tile_height will be set using the Surface dimensions.
+        Its gid will be 0.
+        '''
+        class ts:
+            tile_width, tile_height = surface.get_size()
+        return cls(0, surface, ts)
+
+    def loadxml(self, tag):
+        props = tag.find('properties')
+        if props is None:
+            return
+        for c in props.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            self.properties[name] = value
+
+    def __repr__(self):
+        return '<Tile %d>' % self.gid
+
+
+class Tileset(object):
+    def __init__(self, name, tile_width, tile_height, firstgid):
+        self.name = name
+        self.tile_width = tile_width
+        self.tile_height = tile_height
+        self.firstgid = firstgid
+        self.tiles = []
+        self.properties = {}
+
+    @classmethod
+    def fromxml(cls, tag, firstgid=None):
+        if 'source' in tag.attrib:
+            firstgid = int(tag.attrib['firstgid'])
+            with open(tag.attrib['source']) as f:
+                tileset = ElementTree.fromstring(f.read())
+            return cls.fromxml(tileset, firstgid)
+
+        name = tag.attrib['name']
+        if firstgid is None:
+            firstgid = int(tag.attrib['firstgid'])
+        tile_width = int(tag.attrib['tilewidth'])
+        tile_height = int(tag.attrib['tileheight'])
+
+        tileset = cls(name, tile_width, tile_height, firstgid)
+
+        for c in tag.getchildren():
+            if c.tag == "image":
+                # create a tileset
+                tileset.add_image(c.attrib['source'])
+            elif c.tag == 'tile':
+                gid = tileset.firstgid + int(c.attrib['id'])
+                tileset.get_tile(gid).loadxml(c)
+        return tileset
+
+    def add_image(self, file):
+        image = pygame.image.load(file).convert_alpha()
+        if not image:
+            sys.exit("Error creating new Tileset: file %s not found" % file)
+        id = self.firstgid
+        for line in range(image.get_height() // self.tile_height):
+            for column in range(image.get_width() // self.tile_width):
+                pos = Rect(column * self.tile_width, line * self.tile_height,
+                    self.tile_width, self.tile_height)
+                self.tiles.append(Tile(id, image.subsurface(pos), self))
+                id += 1
+
+    def get_tile(self, gid):
+        return self.tiles[gid - self.firstgid]
+
+
+class Tilesets(dict):
+    def add(self, tileset):
+        for i, tile in enumerate(tileset.tiles):
+            i += tileset.firstgid
+            self[i] = tile
+
+
+class Cell(object):
+    '''Layers are made of Cells (or empty space).
+
+    Cells have some basic properties:
+
+    x, y - the cell's index in the layer
+    px, py - the cell's pixel position
+    left, right, top, bottom - the cell's pixel boundaries
+
+    Additionally the cell may have other properties which are accessed using
+    standard dictionary methods:
+
+       cell['property name']
+
+    You may assign a new value for a property to or even delete an existing
+    property from the cell - this will not affect the Tile or any other Cells
+    using the Cell's Tile.
+    '''
+    def __init__(self, x, y, px, py, tile):
+        self.x, self.y = x, y
+        self.px, self.py = px, py
+        self.tile = tile
+        self.topleft = (px, py)
+        self.left = px
+        self.right = px + tile.tile_width
+        self.top = py
+        self.bottom = py + tile.tile_height
+        self.center = (px + tile.tile_width // 2, py + tile.tile_height // 2)
+        self._added_properties = {}
+        self._deleted_properties = set()
+
+    def __repr__(self):
+        return '<Cell %s,%s %d>' % (self.px, self.py, self.tile.gid)
+
+    def __contains__(self, key):
+        if key in self._deleted_properties:
+            return False
+        return key in self._added_properties or key in self.tile.properties
+
+    def __getitem__(self, key):
+        if key in self._deleted_properties:
+            raise KeyError(key)
+        if key in self._added_properties:
+            return self._added_properties[key]
+        if key in self.tile.properties:
+            return self.tile.properties[key]
+        raise KeyError(key)
+
+    def __setitem__(self, key, value):
+        self._added_properties[key] = value
+
+    def __delitem__(self, key):
+        self._deleted_properties.add(key)
+
+    def intersects(self, other):
+        '''Determine whether this Cell intersects with the other rect (which has
+        .x, .y, .width and .height attributes.)
+        '''
+        if self.px + self.tile.tile_width < other.x:
+            return False
+        if other.x + other.width - 1 < self.px:
+            return False
+        if self.py + self.tile.tile_height < other.y:
+            return False
+        if other.y + other.height - 1 < self.py:
+            return False
+        return True
+
+
+class LayerIterator(object):
+    '''Iterates over all the cells in a layer in column,row order.
+    '''
+    def __init__(self, layer):
+        self.layer = layer
+        self.i, self.j = 0, 0
+
+    def __next__(self):
+        if self.i == self.layer.width - 1:
+            self.j += 1
+            self.i = 0
+        if self.j == self.layer.height - 1:
+            raise StopIteration()
+        value = self.layer[self.i, self.j]
+        self.i += 1
+        return value
+
+
+class Layer(object):
+    '''A 2d grid of Cells.
+
+    Layers have some basic properties:
+
+        width, height - the dimensions of the Layer in cells
+        tile_width, tile_height - the dimensions of each cell
+        px_width, px_height - the dimensions of the Layer in pixels
+        tilesets - the tilesets used in this Layer (a Tilesets instance)
+        properties - any properties set for this Layer
+        cells - a dict of all the Cell instances for this Layer, keyed off
+                (x, y) index.
+
+    Additionally you may look up a cell using direct item access:
+
+       layer[x, y] is layer.cells[x, y]
+
+    Note that empty cells will be set to None instead of a Cell instance.
+    '''
+    def __init__(self, name, visible, map):
+        self.name = name
+        self.visible = visible
+        self.position = (0, 0)
+        # TODO get from TMX?
+        self.px_width = map.px_width
+        self.px_height = map.px_height
+        self.tile_width = map.tile_width
+        self.tile_height = map.tile_height
+        self.width = map.width
+        self.height = map.height
+        self.tilesets = map.tilesets
+        self.group = pygame.sprite.Group()
+        self.properties = {}
+        self.cells = {}
+
+    def __repr__(self):
+        return '<Layer "%s" at 0x%x>' % (self.name, id(self))
+
+    def __getitem__(self, pos):
+        return self.cells.get(pos)
+
+    def __setitem__(self, pos, tile):
+        x, y = pos
+        px = x * self.tile_width
+        py = y * self.tile_width
+        self.cells[pos] = Cell(x, y, px, py, tile)
+
+    def __iter__(self):
+        return LayerIterator(self)
+
+    @classmethod
+    def fromxml(cls, tag, map):
+        layer = cls(tag.attrib['name'], int(tag.attrib.get('visible', 1)), map)
+
+        data = tag.find('data')
+        if data is None:
+            raise ValueError('layer %s does not contain <data>' % layer.name)
+
+        data = data.text.strip()
+        data = data.encode() # Convert to bytes
+        # Decode from base 64 and decompress via zlib 
+        data = decompress(b64decode(data)) 
+        data = struct.unpack('<%di' % (len(data)/4,), data)
+        assert len(data) == layer.width * layer.height
+        for i, gid in enumerate(data):
+            if gid < 1: continue   # not set
+            tile = map.tilesets[gid]
+            x = i % layer.width
+            y = i // layer.width
+            layer.cells[x,y] = Cell(x, y, x*map.tile_width, y*map.tile_height, tile)
+
+        return layer
+
+    def update(self, dt, *args):
+        pass
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.position = (x, y)
+
+    def draw(self, surface):
+        '''Draw this layer, limited to the current viewport, to the Surface.
+        '''
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+        for x in range(ox, ox + w + self.tile_width, self.tile_width):
+            i = x // self.tile_width
+            for y in range(oy, oy + h + self.tile_height, self.tile_height):
+                j = y // self.tile_height
+                if (i, j) not in self.cells:
+                    continue
+                cell = self.cells[i, j]
+                surface.blit(cell.tile.surface, (cell.px - ox, cell.py - oy))
+
+    def find(self, *properties):
+        '''Find all cells with the given properties set.
+        '''
+        r = []
+        for propname in properties:
+            for cell in list(self.cells.values()):
+                if cell and propname in cell:
+                    r.append(cell)
+        return r
+
+    def match(self, **properties):
+        '''Find all cells with the given properties set to the given values.
+        '''
+        r = []
+        for propname in properties:
+            for cell in list(self.cells.values()):
+                if propname not in cell:
+                    continue
+                if properties[propname] == cell[propname]:
+                    r.append(cell)
+        return r
+
+    def collide(self, rect, propname):
+        '''Find all cells the rect is touching that have the indicated property
+        name set.
+        '''
+        r = []
+        for cell in self.get_in_region(rect.left, rect.top, rect.right,
+                rect.bottom):
+            if not cell.intersects(rect):
+                continue
+            if propname in cell:
+                r.append(cell)
+        return r
+
+    def get_in_region(self, x1, y1, x2, y2):
+        '''Return cells (in [column][row]) that are within the map-space
+        pixel bounds specified by the bottom-left (x1, y1) and top-right
+        (x2, y2) corners.
+
+        Return a list of Cell instances.
+        '''
+        i1 = max(0, x1 // self.tile_width)
+        j1 = max(0, y1 // self.tile_height)
+        i2 = min(self.width, x2 // self.tile_width + 1)
+        j2 = min(self.height, y2 // self.tile_height + 1)
+        return [self.cells[i, j]
+            for i in range(int(i1), int(i2))
+                for j in range(int(j1), int(j2))
+                    if (i, j) in self.cells]
+
+    def get_at(self, x, y):
+        '''Return the cell at the nominated (x, y) coordinate.
+
+        Return a Cell instance or None.
+        '''
+        i = x // self.tile_width
+        j = y // self.tile_height
+        return self.cells.get((i, j))
+
+    def neighbors(self, index):
+        '''Return the indexes of the valid (ie. within the map) cardinal (ie.
+        North, South, East, West) neighbors of the nominated cell index.
+
+        Returns a list of 2-tuple indexes.
+        '''
+        i, j = index
+        n = []
+        if i < self.width - 1:
+            n.append((i + 1, j))
+        if i > 0:
+            n.append((i - 1, j))
+        if j < self.height - 1:
+            n.append((i, j + 1))
+        if j > 0:
+            n.append((i, j - 1))
+        return n
+
+
+class Object(object):
+    '''An object in a TMX object layer.
+name: The name of the object. An arbitrary string.
+type: The type of the object. An arbitrary string.
+x: The x coordinate of the object in pixels.
+y: The y coordinate of the object in pixels.
+width: The width of the object in pixels (defaults to 0).
+height: The height of the object in pixels (defaults to 0).
+gid: An reference to a tile (optional).
+visible: Whether the object is shown (1) or hidden (0). Defaults to 1.
+    '''
+    def __init__(self, type, x, y, width=0, height=0, name=None,
+            gid=None, tile=None, visible=1):
+        self.type = type
+        self.px = x
+        self.left = x
+        if tile:
+            y -= tile.tile_height
+            width = tile.tile_width
+            height = tile.tile_height
+        self.py = y
+        self.top = y
+        self.width = width
+        self.right = x + width
+        self.height = height
+        self.bottom = y + height
+        self.name = name
+        self.gid = gid
+        self.tile = tile
+        self.visible = visible
+        self.properties = {}
+
+        self._added_properties = {}
+        self._deleted_properties = set()
+
+    def __repr__(self):
+        if self.tile:
+            return '<Object %s,%s %s,%s tile=%d>' % (self.px, self.py, self.width, self.height, self.gid)
+        else:
+            return '<Object %s,%s %s,%s>' % (self.px, self.py, self.width, self.height)
+
+    def __contains__(self, key):
+        if key in self._deleted_properties:
+            return False
+        if key in self._added_properties:
+            return True
+        if key in self.properties:
+            return True
+        return self.tile and key in self.tile.properties
+
+    def __getitem__(self, key):
+        if key in self._deleted_properties:
+            raise KeyError(key)
+        if key in self._added_properties:
+            return self._added_properties[key]
+        if key in self.properties:
+            return self.properties[key]
+        if self.tile and key in self.tile.properties:
+            return self.tile.properties[key]
+        raise KeyError(key)
+
+    def __setitem__(self, key, value):
+        self._added_properties[key] = value
+
+    def __delitem__(self, key):
+        self._deleted_properties.add(key)
+
+    def draw(self, surface, view_x, view_y):
+        if not self.visible:
+            return
+        x, y = (self.px - view_x, self.py - view_y)
+        if self.tile:
+            surface.blit(self.tile.surface, (x, y))
+        else:
+            r = pygame.Rect((x, y), (self.width, self.height))
+            pygame.draw.rect(surface, (255, 100, 100), r, 2)
+
+    @classmethod
+    def fromxml(cls, tag, map):
+        if 'gid' in tag.attrib:
+            gid = int(tag.attrib['gid'])
+            tile = map.tilesets[gid]
+            w = tile.tile_width
+            h = tile.tile_height
+        else:
+            gid = None
+            tile = None
+            w = int(tag.attrib['width'])
+            h = int(tag.attrib['height'])
+
+        o = cls(tag.attrib.get('type', 'rect'), int(tag.attrib['x']),
+            int(tag.attrib['y']), w, h, tag.attrib.get('name'), gid, tile,
+            int(tag.attrib.get('visible', 1)))
+
+        props = tag.find('properties')
+        if props is None:
+            return o
+
+        for c in props.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            o.properties[name] = value
+        return o
+
+    def intersects(self, x1, y1, x2, y2):
+        if x2 < self.px:
+            return False
+        if y2 < self.py:
+            return False
+        if x1 > self.px + self.width:
+            return False
+        if y1 > self.py + self.height:
+            return False
+        return True
+
+
+class ObjectLayer(object):
+    '''A layer composed of basic primitive shapes.
+
+    Actually encompasses a TMX <objectgroup> but even the TMX documentation
+    refers to them as object layers, so I will.
+
+    ObjectLayers have some basic properties:
+
+        position - ignored (cannot be edited in the current Tiled editor)
+        name - the name of the object group.
+        color - the color used to display the objects in this group.
+        opacity - the opacity of the layer as a value from 0 to 1.
+        visible - whether the layer is shown (1) or hidden (0).
+        objects - the objects in this Layer (Object instances)
+    '''
+    def __init__(self, name, color, objects, opacity=1,
+            visible=1, position=(0, 0)):
+        self.name = name
+        self.color = color
+        self.objects = objects
+        self.opacity = opacity
+        self.visible = visible
+        self.position = position
+        self.properties = {}
+
+    def __repr__(self):
+        return '<ObjectLayer "%s" at 0x%x>' % (self.name, id(self))
+
+    @classmethod
+    def fromxml(cls, tag, map):
+        layer = cls(tag.attrib['name'], tag.attrib.get('color'), [],
+            float(tag.attrib.get('opacity', 1)),
+            int(tag.attrib.get('visible', 1)))
+        for object in tag.findall('object'):
+            layer.objects.append(Object.fromxml(object, map))
+        for c in tag.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            layer.properties[name] = value
+        return layer
+
+    def update(self, dt, *args):
+        pass
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.position = (x, y)
+
+    def draw(self, surface):
+        '''Draw this layer, limited to the current viewport, to the Surface.
+        '''
+        if not self.visible:
+            return
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+        for object in self.objects:
+            object.draw(surface, self.view_x, self.view_y)
+
+    def find(self, *properties):
+        '''Find all cells with the given properties set.
+        '''
+        r = []
+        for propname in properties:
+            for object in self.objects:
+                if object and propname in object or propname in self.properties:
+                    r.append(object)
+        return r
+
+    def match(self, **properties):
+        '''Find all objects with the given properties set to the given values.
+        '''
+        r = []
+        for propname in properties:
+            for object in self.objects:
+                if propname in object:
+                    val = object[propname]
+                elif propname in self.properties:
+                    val = self.properties[propname]
+                else:
+                    continue
+                if properties[propname] == val:
+                    r.append(object)
+        return r
+
+    def collide(self, rect, propname):
+        '''Find all objects the rect is touching that have the indicated
+        property name set.
+        '''
+        r = []
+        for object in self.get_in_region(rect.left, rect.top, rect.right,
+                rect.bottom):
+            if propname in object or propname in self.properties:
+                r.append(object)
+        return r
+
+    def get_in_region(self, x1, y1, x2, y2):
+        '''Return objects that are within the map-space
+        pixel bounds specified by the bottom-left (x1, y1) and top-right
+        (x2, y2) corners.
+
+        Return a list of Object instances.
+        '''
+        return [obj for obj in self.objects if obj.intersects(x1, y1, x2, y2)]
+
+    def get_at(self, x, y):
+        '''Return the first object found at the nominated (x, y) coordinate.
+
+        Return an Object instance or None.
+        '''
+        for object in self.objects:
+            if object.contains(x,y):
+                return object
+
+
+class SpriteLayer(pygame.sprite.AbstractGroup):
+    def __init__(self):
+        super(SpriteLayer, self).__init__()
+        self.visible = True
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.dx = viewport_ox
+        self.dy = viewport_oy
+        self.position = (x, y)
+
+    def draw(self, screen):
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+        
+        for sprite in self.sprites():
+            sx, sy = sprite.rect.topleft
+            # Only the sprite's defined width and height will be drawn
+            area = pygame.Rect((0, 0),
+                               (sprite.rect.width,
+                                sprite.rect.height))
+            screen.blit(sprite.image, (sx-ox, sy-oy), area)
+
+class Layers(list):
+    def __init__(self):
+        self.by_name = {}
+
+    def add_named(self, layer, name):
+        self.append(layer)
+        self.by_name[name] = layer
+
+    def __getitem__(self, item):
+        if isinstance(item, int):
+            return self[item]
+        return self.by_name[item]
+
+class TileMap(object):
+    '''A TileMap is a collection of Layers which contain gridded maps or sprites
+    which are drawn constrained by a viewport.
+
+    And breathe.
+
+    TileMaps are loaded from TMX files which sets the .layers and .tilesets
+    properties. After loading additional SpriteLayers may be added.
+
+    A TileMap's rendering is restricted by a viewport which is defined by the
+    size passed in at construction time and the focus set by set_focus() or
+    force_focus().
+
+    TileMaps have a number of properties:
+
+        width, height - the dimensions of the tilemap in cells
+        tile_width, tile_height - the dimensions of the cells in the map
+        px_width, px_height - the dimensions of the tilemap in pixels
+        properties - any properties set on the tilemap in the TMX file
+        layers - all layers of this tilemap as a Layers instance
+        tilesets - all tilesets of this tilemap as a Tilesets instance
+        fx, fy - viewport focus point
+        view_w, view_h - viewport size
+        view_x, view_y - viewport offset (origin)
+        viewport - a Rect instance giving the current viewport specification
+
+    '''
+    def __init__(self, size, origin=(0,0)):
+        self.px_width = 0
+        self.px_height = 0
+        self.tile_width = 0
+        self.tile_height = 0
+        self.width = 0
+        self.height  = 0
+        self.properties = {}
+        self.layers = Layers()
+        self.tilesets = Tilesets()
+        self.fx, self.fy = 0, 0             # viewport focus point
+        self.view_w, self.view_h = size     # viewport size
+        self.view_x, self.view_y = origin   # viewport offset
+        self.viewport = Rect(origin, size)
+
+    def update(self, dt, *args):
+        for layer in self.layers:
+            layer.update(dt, *args)
+
+    def draw(self, screen):
+        for layer in self.layers:
+            if layer.visible:
+                layer.draw(screen)
+
+    @classmethod
+    def load(cls, filename, viewport):
+        with open(filename) as f:
+            map = ElementTree.fromstring(f.read())
+
+        # get most general map informations and create a surface
+        tilemap = TileMap(viewport)
+        tilemap.width = int(map.attrib['width'])
+        tilemap.height  = int(map.attrib['height'])
+        tilemap.tile_width = int(map.attrib['tilewidth'])
+        tilemap.tile_height = int(map.attrib['tileheight'])
+        tilemap.px_width = tilemap.width * tilemap.tile_width
+        tilemap.px_height = tilemap.height * tilemap.tile_height
+
+        for tag in map.findall('tileset'):
+            tilemap.tilesets.add(Tileset.fromxml(tag))
+
+        for tag in map.findall('layer'):
+            layer = Layer.fromxml(tag, tilemap)
+            tilemap.layers.add_named(layer, layer.name)
+
+        for tag in map.findall('objectgroup'):
+            layer = ObjectLayer.fromxml(tag, tilemap)
+            tilemap.layers.add_named(layer, layer.name)
+
+        return tilemap
+
+    _old_focus = None
+    def set_focus(self, fx, fy, force=False):
+        '''Determine the viewport based on a desired focus pixel in the
+        Layer space (fx, fy) and honoring any bounding restrictions of
+        child layers.
+
+        The focus will always be shifted to ensure no child layers display
+        out-of-bounds data, as defined by their dimensions px_width and px_height.
+        '''
+        # The result is that all chilren will have their viewport set, defining
+        # which of their pixels should be visible.
+        fx, fy = int(fx), int(fy)
+        self.fx, self.fy = fx, fy
+
+        a = (fx, fy)
+
+        # check for NOOP (same arg passed in)
+        if not force and self._old_focus == a:
+            return
+        self._old_focus = a
+
+        # get our viewport information, scaled as appropriate
+        w = int(self.view_w)
+        h = int(self.view_h)
+        w2, h2 = w//2, h//2
+
+        if self.px_width <= w:
+            # this branch for centered view and no view jump when
+            # crossing the center; both when world width <= view width
+            restricted_fx = self.px_width / 2
+        else:
+            if (fx - w2) < 0:
+                restricted_fx = w2       # hit minimum X extent
+            elif (fx + w2) > self.px_width:
+                restricted_fx = self.px_width - w2       # hit maximum X extent
+            else:
+                restricted_fx = fx
+        if self.px_height <= h:
+            # this branch for centered view and no view jump when
+            # crossing the center; both when world height <= view height
+            restricted_fy = self.px_height / 2
+        else:
+            if (fy - h2) < 0:
+                restricted_fy = h2       # hit minimum Y extent
+            elif (fy + h2) > self.px_height:
+                restricted_fy = self.px_height - h2       # hit maximum Y extent
+            else:
+                restricted_fy = fy
+
+        # ... and this is our focus point, center of screen
+        self.restricted_fx = int(restricted_fx)
+        self.restricted_fy = int(restricted_fy)
+
+        # determine child view bounds to match that focus point
+        x, y = int(restricted_fx - w2), int(restricted_fy - h2)
+        self.viewport.x = x
+        self.viewport.y = y
+
+        self.childs_ox = x - self.view_x
+        self.childs_oy = y - self.view_y
+
+        for layer in self.layers:
+            layer.set_view(x, y, w, h, self.view_x, self.view_y)
+
+    def force_focus(self, fx, fy):
+        '''Force the manager to focus on a point, regardless of any managed layer
+        visible boundaries.
+
+        '''
+        # This calculation takes into account the scaling of this Layer (and
+        # therefore also its children).
+        # The result is that all chilren will have their viewport set, defining
+        # which of their pixels should be visible.
+        self.fx, self.fy = list(map(int, (fx, fy)))
+        self.fx, self.fy = fx, fy
+
+        # get our view size
+        w = int(self.view_w)
+        h = int(self.view_h)
+        w2, h2 = w//2, h//2
+
+        # bottom-left corner of the viewport
+        x, y = fx - w2, fy - h2
+        self.viewport.x = x
+        self.viewport.y = y
+
+        self.childs_ox = x - self.view_x
+        self.childs_oy = y - self.view_y
+
+        for layer in self.layers:
+            layer.set_view(x, y, w, h, self.view_x, self.view_y)
+
+    def pixel_from_screen(self, x, y):
+        '''Look up the Layer-space pixel matching the screen-space pixel.
+        '''
+        vx, vy = self.childs_ox, self.childs_oy
+        return int(vx + x), int(vy + y)
+
+    def pixel_to_screen(self, x, y):
+        '''Look up the screen-space pixel matching the Layer-space pixel.
+        '''
+        screen_x = x-self.childs_ox
+        screen_y = y-self.childs_oy
+        return int(screen_x), int(screen_y)
+
+    def index_at(self, x, y):
+        '''Return the map index at the (screen-space) pixel position.
+        '''
+        sx, sy = self.pixel_from_screen(x, y)
+        return int(sx//self.tile_width), int(sy//self.tile_height)
+
+def load(filename, viewport):
+    return TileMap.load(filename, viewport)
+
+if __name__ == '__main__':
+    # allow image load to work
+    pygame.init()
+    pygame.display.set_mode((640, 480))
+    t = load(sys.argv[1], (0, 0))
Index: NEAT/evoman/map1.tmx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/map1.tmx b/NEAT/evoman/map1.tmx
new file mode 100644
--- /dev/null	(date 1632487473284)
+++ b/NEAT/evoman/map1.tmx	(date 1632487473284)
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" width="23" height="16" tilewidth="32" tileheight="32">
+ <tileset firstgid="1" source="evoman/roles.tsx"/>
+ <tileset firstgid="9" name="wall1" tilewidth="32" tileheight="32">
+  <image source="evoman/images/wall1.jpg" width="700" height="466"/>
+ </tileset>
+ <tileset firstgid="303" name="roles" tilewidth="32" tileheight="32">
+  <image source="evoman/images/roles.png" trans="ff00ff" width="450" height="32"/>
+  <tile id="0">
+   <properties>
+    <property name="player" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="1">
+   <properties>
+    <property name="enemy" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="2">
+   <properties>
+    <property name="exit" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="3">
+   <properties>
+    <property name="reverse" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="life" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="hd" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="plat" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="7">
+   <properties>
+    <property name="gun" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="8">
+   <properties>
+    <property name="spike" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="9">
+   <properties>
+    <property name="spike2" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="10">
+   <properties>
+    <property name="score" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="11">
+   <properties>
+    <property name="medicine" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="12">
+   <properties>
+    <property name="spike3" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="spike4" value="yes"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="317" name="wall2" tilewidth="32" tileheight="32">
+  <image source="evoman/images/wall2.jpg" trans="ff00ff" width="100" height="67"/>
+ </tileset>
+ <tileset firstgid="323" name="plataform1" tilewidth="32" tileheight="32">
+  <image source="evoman/images/plataform1.jpg" trans="ff00ff" width="100" height="63"/>
+ </tileset>
+ <layer name="set" width="23" height="16" opacity="0.99">
+  <data encoding="base64" compression="zlib">
+   eJzt0ddXzgEcx/EfualIkr2LUGZG9qqMyorsmexNJE0rhOxN5oVRFzLu5E7+LK/O8ZzzO13kOKfuXLzO7/P8nu/zvnmigiDoRleiOnjP6xIE0Z4xxNKdHsTRk3h6kUBvEulDX/rRnwEMZBCDGfKn29ntofYwhjOCJJIZyShSGM0YxpJKGuMYzwQmMonJpIfaU+ypTGM6GcxgJrOYzRzmtv6G+SxgIYvIJItsFrMk1F5qLyOHXPJYzgpWsorV5LOGtRSwjvVsYCOb2MyWUHurvY3t7GAnheyiiN3sYS/72M8BDnKIwxzhKMc4HmqfsE9SzClOU8IZSjlLGeVUUEkV1ZzjPBe4yCVqQu3L9hWuUss1rnODOm5yi9vc4S73uM8DHvKIxzzhaaj9zH5OPS94ySte84a3rf+Xuyyyeefzez7wkQYa29xE2p+8b+IzX/jKtza34f3dd838aOcm0v7ppoVf7dz+6460O6r3v/339m9AHmsJ
+  </data>
+ </layer>
+ <objectgroup name="triggers" width="23" height="16" visible="0">
+  <object name="floor" x="30" y="385" width="97" height="35">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object gid="303" x="50" y="329"/>
+  <object gid="304" x="640" y="234"/>
+  <object name="floor" x="0" y="2" width="740" height="27">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="1" y="30" width="28" height="353">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="706" y="31" width="29" height="257">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="415" y="353" width="97" height="35">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="513" y="320" width="96" height="66">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="608" y="289" width="104" height="66">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="128" y="352" width="95" height="68">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="223" y="320" width="97" height="62">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="320" y="289" width="95" height="96">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+ </objectgroup>
+</map>
Index: NEAT/evoman/map2.tmx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/map2.tmx b/NEAT/evoman/map2.tmx
new file mode 100644
--- /dev/null	(date 1632487473299)
+++ b/NEAT/evoman/map2.tmx	(date 1632487473299)
@@ -0,0 +1,114 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" width="23" height="16" tilewidth="32" tileheight="32">
+ <tileset firstgid="1" name="roles" tilewidth="32" tileheight="32">
+  <image source="evoman/images/roles.png" trans="ff00ff" width="450" height="32"/>
+  <tile id="0">
+   <properties>
+    <property name="player" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="1">
+   <properties>
+    <property name="enemy" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="2">
+   <properties>
+    <property name="exit" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="3">
+   <properties>
+    <property name="reverse" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="life" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="hd" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="plat" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="7">
+   <properties>
+    <property name="gun" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="8">
+   <properties>
+    <property name="spike" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="9">
+   <properties>
+    <property name="spike2" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="10">
+   <properties>
+    <property name="score" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="11">
+   <properties>
+    <property name="medicine" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="12">
+   <properties>
+    <property name="spike3" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="spike4" value="yes"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="15" name="images" tilewidth="32" tileheight="32">
+  <image source="evoman/images/images.jpg" trans="ff00ff" width="225" height="225"/>
+ </tileset>
+ <tileset firstgid="64" name="download" tilewidth="32" tileheight="32">
+  <image source="evoman/images/download.jpg" trans="ff00ff" width="284" height="177"/>
+ </tileset>
+ <tileset firstgid="104" name="tex3" tilewidth="32" tileheight="32">
+  <image source="evoman/images/tex3.jpg" trans="ff00ff" width="270" height="186"/>
+ </tileset>
+ <layer name="set" width="23" height="16">
+  <data encoding="base64" compression="zlib">
+   eJy11EcOAjEMheG5Ab13uBy99957uTL/JlJkwURAWHyajJ9lRV4k6DhOCB544YMfAQR/zCKIIqydY4gjgeQXmfpX3xHGmGCKGeZYvKm59cvZK6yxwRY77HF4U3Pr/+Teeqafbdxbz/Sz7XurzNa+X2Wf7LuIEsqooIoa6miImqlXzm6ihTY66KKHPgaiZuqVs4eGHeo1U6+cvTTsUK+ZeuXsI04444IrbrjjIWqmXjXzH2+Uymy+UTJLIY0Mssghj4KF7AlW5nVa
+  </data>
+ </layer>
+ <objectgroup name="triggers" width="23" height="16" visible="0">
+  <object gid="1" x="101" y="353"/>
+  <object gid="2" x="588" y="356"/>
+  <object name="floor" x="0" y="2" width="735" height="28">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="1" y="30" width="59" height="450">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="677" y="32" width="58" height="450">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="4" y="419" width="731" height="95">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+ </objectgroup>
+</map>
Index: NEAT/evoman/map3.tmx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/map3.tmx b/NEAT/evoman/map3.tmx
new file mode 100644
--- /dev/null	(date 1632487473299)
+++ b/NEAT/evoman/map3.tmx	(date 1632487473299)
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" width="23" height="16" tilewidth="32" tileheight="32">
+ <tileset firstgid="1" source="evoman/roles3.tsx"/>
+ <tileset firstgid="15" name="tex2" tilewidth="32" tileheight="32">
+  <image source="evoman/images/tex2.jpg" trans="ff00ff" width="284" height="177"/>
+ </tileset>
+ <tileset firstgid="55" name="tex4" tilewidth="32" tileheight="32">
+  <image source="evoman/images/tex4.jpg" trans="ff00ff" width="183" height="274"/>
+ </tileset>
+ <layer name="set" width="23" height="16">
+  <data encoding="base64" compression="zlib">
+   eJzt1DkOwjAUhGFfhe0MYYcOkACxQ9jufwz+4lkaWS9ikUUDxSfLY2dSOHERQmijgy56KDJlfQwwxAjjjNnB7G084oTySRbnK6yxwRY76YyWpoGmzKdmYuMMcyxs3Xt/2l1DXbpbSaZ9uu+MC6644f5Bd1Xm7fl3/063/mv6nObvduuz8Xv2sjT3unPdS9++q6rO65Uz033e+gOljU6A
+  </data>
+ </layer>
+ <objectgroup name="triggers" width="23" height="16" visible="0">
+  <object gid="1" x="72" y="323"/>
+  <object gid="2" x="628" y="340"/>
+  <object name="floor" x="0" y="2" width="735" height="28">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="1" y="30" width="59" height="450">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="677" y="32" width="58" height="450">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="62" y="418" width="66" height="27">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="576" y="416" width="100" height="27">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="127" y="384" width="66" height="34">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="288" y="386" width="100" height="27">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="479" y="386" width="99" height="33">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="191" y="354" width="96" height="37">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object x="384" y="354" width="94" height="35">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+ </objectgroup>
+</map>
Index: NEAT/evoman/map4.tmx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/map4.tmx b/NEAT/evoman/map4.tmx
new file mode 100644
--- /dev/null	(date 1632487473315)
+++ b/NEAT/evoman/map4.tmx	(date 1632487473315)
@@ -0,0 +1,119 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" width="23" height="16" tilewidth="32" tileheight="32">
+ <tileset firstgid="1" name="roles" tilewidth="32" tileheight="32">
+  <image source="evoman/images/roles.png" trans="ff00ff" width="450" height="32"/>
+  <tile id="0">
+   <properties>
+    <property name="player" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="1">
+   <properties>
+    <property name="enemy" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="2">
+   <properties>
+    <property name="exit" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="3">
+   <properties>
+    <property name="reverse" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="life" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="hd" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="plat" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="7">
+   <properties>
+    <property name="gun" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="8">
+   <properties>
+    <property name="spike" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="9">
+   <properties>
+    <property name="spike2" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="10">
+   <properties>
+    <property name="score" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="11">
+   <properties>
+    <property name="medicine" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="12">
+   <properties>
+    <property name="spike3" value="yes"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="spike4" value="yes"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="15" name="download" tilewidth="32" tileheight="32">
+  <image source="evoman/images/download.jpg" trans="ff00ff" width="284" height="177"/>
+ </tileset>
+ <tileset firstgid="55" name="water2" tilewidth="32" tileheight="32">
+  <image source="evoman/images/water2.jpg" trans="ff00ff" width="1300" height="800"/>
+ </tileset>
+ <tileset firstgid="1055" name="bb" tilewidth="32" tileheight="32">
+  <image source="evoman/images/bb.jpeg" trans="ff00ff" width="240" height="179"/>
+ </tileset>
+ <layer name="set" width="23" height="16" opacity="0.99">
+  <data encoding="base64" compression="zlib">
+   eJyl1EdwVmUYhuHzx2gaCiqo4EIRSAXTFLEROgTSo7RQBEsaNuyyUDrSQgJWkKILOyiWFASUIqILey9pKBYU1IUdvDJxJv+KTRbXzD3znXnnWZ34yCBIIJEkkkmhP/GdfEsjKwiCIQxlGMMZwUhGMZoxZDOWceSQSx75FFBIEcVB+92LKNVllFNBJbO4nhu4kZu4mdncwq3cxu3cwZ3cxd3MCdrvtt2v0quopobVrOF+HuBBHuJhHmEt63iU9WxgI5t4jMfDdtfqOuppYBuvsp0d7OQ1XmcXu9nDXt5gH2+yn7d4O2x3o26imRZaOcA3fMtBvuN7fuBHDvETP3OYI/zCr/wWtjsqFATRxBBLHF04mVPoSjdO5TROpzs9OIMzOYue9OLsUMfuVJ1GOhlkcgEXMrDtOwZxMZdwKZdxOYPJYghDGcbwUMfuCXoik5hMCVOYyjSmcxUzmMnVXMO1XEcpZZRTQWXY7nv0vcxlHvNZwEIWsZgl3MdSlrGcFaykilVUU8PqsN1P6Cd5iqd5hmd5js1s4XleYCsv8hIv8wq11FFPA9vCdr+j3+U93ucDPuQjPuYTPuUzPucLvuQrvqaRJpppoTVs9+/6D/7kL/7mH/7lKMcIIoIgRAQnEMmJnEQU0cQQS1xEx+5z9Ln05jz60Jd+xJNAIkkkk0J/BnA+qaSRTgaZER27R+sxZDOWceSQSx75FFBIEcVcwZWMZwITmcRkSv7f3dn/6PHe/gMGQZqA
+  </data>
+ </layer>
+ <objectgroup name="triggers" width="23" height="16" visible="0">
+  <object gid="1" x="59" y="449"/>
+  <object gid="2" x="635" y="449"/>
+  <object name="floor" x="0" y="2" width="733" height="8">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="0" y="2" width="29" height="478">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="703" y="3" width="30" height="479">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="floor" x="2" y="481" width="729" height="28">
+   <properties>
+    <property name="blockers" value="tlrb"/>
+   </properties>
+  </object>
+  <object name="spikes" x="1" y="12" width="733" height="146">
+   <properties>
+    <property name="killers" value="tlrb"/>
+   </properties>
+  </object>
+ </objectgroup>
+</map>
Index: NEAT/evoman/enemy1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy1.py b/NEAT/evoman/enemy1.py
new file mode 100644
--- /dev/null	(date 1632487473315)
+++ b/NEAT/evoman/enemy1.py	(date 1632487473315)
@@ -0,0 +1,323 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map1.tmx'  # scenario
+timeexpire = 1000 # game run limit
+
+
+# enemy 1 sprite, flashman
+class Enemy(pygame.sprite.Sprite):
+
+
+    def __init__(self, location, *groups):
+
+        super(Enemy, self).__init__(*groups)
+
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.time_colis = 0
+        self.alternate = 1
+        self.imune = 0
+        self.timeenemy = 0
+        self.twists = []
+        self.hurt = 0
+        self.shooting = 1
+        self.gun_cooldown = 0
+        self.gun_cooldown2 = 0
+
+
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+
+        # increments enemy timer
+        if game.start == 1:
+            self.timeenemy += 1
+
+        # defines game mode for player action
+        if game.enemymode == 'static': #  controlled by static movements
+
+            atack1 = 1
+
+            if self.timeenemy >= 200 and self.timeenemy < 260:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy == 220:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            atack4 = 1
+
+
+        elif game.enemymode == 'ai': # enemy controlled by AI algorithm
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 4:
+                game.print_logs("ERROR: Enemy 1 controller must return 4 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+
+
+            # applies attack rules
+            if atack2 == 1 and not self.gun_cooldown:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if atack3 == 1 and not self.gun_cooldown2:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+
+
+        # if the enemy is not atacking with the feezing atack (prevents player from making any movements) and also the 'start game' marker is 1.
+        if game.freeze_e == 0 and game.start == 1:
+
+            last = self.rect.copy()# copies last position state of the enemy
+
+            if atack1 == 1:
+                # moves the enemy on the axis x
+                self.rect.x += self.direction * 100 * dt
+
+                # chases player, switching direction as he moves.
+                if atack4 == 1:
+
+                    if game.enemymode == 'static':
+                        if game.player.rect.right < self.rect.left:
+                            self.direction = -1
+                        elif game.player.rect.left > self.rect.right:
+                             self.direction = 1
+                    else:
+                        self.direction = self.direction * -1
+
+            # animation, running enemy images alternation.
+            if self.direction > 0:
+                direction = SpriteConstants.RIGHT
+            else:
+                direction = SpriteConstants.LEFT
+
+            if self.alternate == 1:
+                self.updateSprite(SpriteConstants.START_RUNNING, direction)
+            if self.alternate == 4 or self.alternate == 10:
+                self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+            if self.alternate == 7:
+                self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+            self.alternate += 1
+            if self.alternate > 12:
+                self.alternate = 1
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # sprite loses life points, according to the difficult level of the game (the more difficult, the more it loses).
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*1))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*1))
+
+                # counts duration of the collision to jump from time to time during the collision
+                self.time_colis += 1
+                if self.time_colis > 15:
+                    self.time_colis = 0
+                    self.dy = -600
+
+                # sets flag to change the player image when he is hurt
+                game.player.hurt = 5
+
+
+            # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits towards enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left  and last.bottom>cell.top:
+                    new.right = cell.left
+                    # Jumps when finds a wall in the middle plataforms.
+                    if new.left<600:
+                        self.dy = -600
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right and last.bottom>cell.top:
+                    new.left = cell.right
+                    # Jumps when finds a wall in the middle plataforms.
+                    if new.left>29:
+                        self.dy = -600
+
+            #  Changes the image when enemy jumps.
+            if self.resting == 0:
+               if self.direction == -1:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+               else:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            # Hurt enemy animation.
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+
+        # Enemy atack: freezes the player (preeveting him from making any movements or atacking) and also himself from moving. Freenzing endures according to the timer.
+        if atack2 == 1:
+
+            self.gun_cooldown = 6
+
+            game.freeze_p = 1
+            game.freeze_e = 1
+
+        # Enemy shooting after freezing.
+        if  atack3 == 1:
+
+            self.shooting = 5
+
+            self.gun_cooldown2 = 6
+
+            # Bullets sound effect.
+            if game.sound == "on" and game.playermode == "human":
+
+                sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                c = pygame.mixer.Channel(3)
+                c.set_volume(10)
+                c.play(sound)
+
+            # Shoots 8 bullets placed in a fixed range with a little random variation in their position (x and y).
+
+
+            for i in range (0,8):
+                rand = numpy.array([30,20,10,15,9,25,18,5])
+                rand2 = numpy.array([1,2,3,4,5,2,4,3])
+
+                rand = rand[i]
+                rand2 = rand2[i]
+
+                # Start position of the bullets vary according to the position of the enemy.
+                if self.direction > 0:
+                    self.twists.append(Bullet_e1((self.rect.x+(i*rand),self.rect.y+10+(i*rand2)), 1, len(self.twists), game.sprite_e))
+                else:
+                    self.twists.append(Bullet_e1((self.rect.x-(i*rand)+46,self.rect.y+10+(i*rand2)), -1, len(self.twists), game.sprite_e))
+
+        # Decreases time for bullets and freezing limitation.
+        self.gun_cooldown = max(0, self.gun_cooldown - dt)
+        self.gun_cooldown2 = max(0, self.gun_cooldown2 - dt)
+
+        # Changes bullets images according to the enemy direction.
+        if self.shooting > 0:
+            if self.direction == -1:
+                self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+            else:
+                self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+        self.shooting -= 1
+        self.shooting = max(0,self.shooting)
+
+        # Releases movement.
+        if  self.gun_cooldown <= 5:
+            game.freeze_p = 0
+            game.freeze_e = 0
+
+        # Reinicializes enemy atacking timer.
+        if self.timeenemy == 260:
+            self.timeenemy = 0
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+# Enemy's bullets.
+class Bullet_e1(pygame.sprite.Sprite):
+
+
+
+    image = pygame.image.load('evoman/images/bullet2_l.png')
+
+    def __init__(self, location, direction, n_twist, *groups):
+        super(Bullet_e1, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.n_twist = n_twist
+
+        # Fits image according to the side the enemy is turned to.
+        if self.direction == 1:
+            self.image = pygame.image.load('evoman/images/bullet2_r.png')
+        else:
+            self.image = pygame.image.load('evoman/images/bullet2_l.png')
+
+
+
+    def update(self, dt, game):
+
+        # Removes bullets objetcs when they transpass the screem limits.
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # Moving on the X axis.
+        self.rect.x += self.direction * 300 * dt
+
+        # Checks collision of enemy's bullet with the player.
+        if self.rect.colliderect(game.player.rect):
+
+            # Player loses life points, accoring to the difficult level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*3))
+
+            # Removes the bullet off the screem after collision.
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+
+            # Sets flag to change the player image when he is hurt.
+            game.player.hurt = 5
Index: NEAT/evoman/enemy2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy2.py b/NEAT/evoman/enemy2.py
new file mode 100644
--- /dev/null	(date 1632487473315)
+++ b/NEAT/evoman/enemy2.py	(date 1632487473315)
@@ -0,0 +1,315 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map2.tmx'
+timeexpire = 1000 # game run limit
+
+# enemy 2 sprite, airman
+class Enemy(pygame.sprite.Sprite):
+
+
+    def __init__(self, location, *groups):
+
+        super(Enemy, self).__init__(*groups)
+
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.twists = []
+        self.alternate = 1
+        self.imune = 0
+        self.timeenemy = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+
+
+    def update(self, dt, game):
+
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([630,610,560,530])
+
+
+        # defines game mode for player action.
+        if game.enemymode == 'static': # enemy controlled by static movements
+
+            if (self.timeenemy >= 210  and self.timeenemy <= 250) or (self.timeenemy >= 260  and self.timeenemy <= 300):
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if self.timeenemy == 210 or self.timeenemy == 260:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy> 300:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            if (self.timeenemy == 40) or (self.timeenemy == 110) or (self.timeenemy == 180):
+                atack4 = 1
+            else:
+                atack4 = 0
+
+
+        elif game.enemymode == 'ai': # player controlled by AI algorithm
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 4:
+                game.print_logs("ERROR: Enemy 1 controller must return 4 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+
+
+            if atack4 == 1 and not self.gun_cooldown:
+                atack4 = 1
+            else:
+                atack4 = 0
+
+            if atack1 == 1 and self.resting == 1:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+
+        # if the 'start game' marker is 1
+        if game.start == 1:
+
+            # increments enemy timer
+            self.timeenemy += 1
+
+            # copies last position state of the enemy
+            last = self.rect.copy()
+
+            # movements of the enemy on the axis x. Happens 2 to each side.
+            if atack1 == 1  :
+                self.rect.x += self.direction * 200 * dt
+
+                # jumps
+                if atack2 == 1:
+                    self.dy = -900
+                    self.resting = 0
+
+               # animation, running enemy images alternatetion.
+                if self.direction > 0:
+                    direction = SpriteConstants.RIGHT
+                else:
+                    direction = SpriteConstants.LEFT
+
+                if self.alternate == 1:
+                    self.updateSprite(SpriteConstants.START_RUNNING, direction)
+                if self.alternate == 4 or self.alternate == 10:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+                if self.alternate == 7:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+                self.alternate += 1
+                if self.alternate > 12:
+                    self.alternate = 1
+
+                #  changes the image when enemy jumps
+                if self.resting == 0:
+                   if self.direction == -1:
+                       self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+                   else:
+                       self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            else:
+                # animation, standing up images
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+            # restart enemy timer and turns the enemy around
+            if atack3 == 1:
+                self.timeenemy = 0
+                self.direction = self.direction * -1
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*1))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*1))
+
+                game.player.hurt = 5 # sets flag to change the player image when he is hurt.
+
+            # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy.
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+            # enemy shoots
+            if atack4 == 1:
+
+                self.shooting = 5
+
+                self.gun_cooldown = 3
+
+                 # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+
+                # shoots 6 bullets placed in a fixed range
+                for i in range (0,6):
+                    self.twists.append(Bullet_e2((self.rect.x+10,self.rect.bottom), self.direction ,i, len(self.twists), game.sprite_e))
+
+            # decreases time for bullets limitation
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)
+
+            # hurt enemy animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+            # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+# enemy's bullet
+class Bullet_e2(pygame.sprite.Sprite):
+
+
+    image = pygame.image.load('evoman/images/torna.png')
+
+    def __init__(self, location, direction,n, n_twist , *groups):
+        super(Bullet_e2, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.lifespan = 55
+        self.n = n
+        self.n_twist = n_twist
+
+
+
+    def update(self, dt, game):
+
+        if game.time%2==0:
+            self.image = pygame.image.load('evoman/images/torna.png')
+        else:
+            self.image = pygame.image.load('evoman/images/torna2.png')
+
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # enemy atack: blows the player forward with the bullets
+        if self.lifespan > 43:
+            ax = [100,380,440,270,220,300]
+            ay = [30,70,120,-40	,80,130]
+
+            if self.direction == -1:
+                if  self.rect.x >= game.enemy.rect.x - ax[self.n]:
+                    self.rect.x -= 1400 * dt
+            if self.direction == 1:
+                if  self.rect.x <= game.enemy.rect.x + ax[self.n]:
+                    self.rect.x += 1400	 * dt
+
+            if  self.rect.y >= game.enemy.rect.y - ay[self.n]:
+                self.rect.y -= 550 * dt
+
+        elif self.lifespan <= 5:
+            self.rect.x += self.direction * 650 * dt
+            game.player.rect.x +=  self.direction *  150 * dt
+
+            # limitates player in the screen.
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+        # decreases bullet's timer
+        self.lifespan -= 1
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, according to the difficult level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*1))
+
+            # sets flag to change the player image when he is hurt
+            game.player.hurt = 5
+
+        # removes player's bullets when colliding with enemy's bullets
+        aux = 0
+        for t in game.player.twists:
+            if t != None:
+                if self.rect.colliderect(t.rect):
+                    t.kill()
+                    game.player.twists[aux] = None
+            aux += 1
Index: NEAT/evoman/enemy3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy3.py b/NEAT/evoman/enemy3.py
new file mode 100644
--- /dev/null	(date 1632487473331)
+++ b/NEAT/evoman/enemy3.py	(date 1632487473331)
@@ -0,0 +1,339 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map2.tmx'
+timeexpire = 1000 # game run limit
+
+# enemy 3 sprite, woodman
+class Enemy(pygame.sprite.Sprite):
+
+
+    def __init__(self, location,*groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.twists = []
+        self.alternate = 1
+        self.imune = 0
+        self.timeenemy = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+        # defines game mode for player action
+        if game.enemymode == 'static': # enemy controlled by static movements
+
+            if self.timeenemy >= 120  and self.timeenemy <= 140:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if self.timeenemy == 130:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy> 140:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            if self.timeenemy == 30:
+                atack4 = 1
+            else:
+                atack4 = 0
+
+
+        elif game.enemymode == 'ai': # player controlled by AI algorithm
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 4:
+                game.print_logs("ERROR: Enemy 1 controller must return 4 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+
+
+            if atack4 == 1 and not self.gun_cooldown:
+                atack4 = 1
+            else:
+                atack4 = 0
+
+
+        # if 'start game' is true
+        if game.start == 1:
+
+            self.timeenemy += 1 # increments enemy timer
+
+
+            # copies last position state of the enemy
+            last = self.rect.copy()
+
+            # movements of the enemy on the axis x
+            if atack1 == 1:
+
+                self.rect.x += self.direction * 180 * dt  # goes forward
+                # jumps
+                if atack2 == 1 and self.resting == 1:
+                    self.dy = -700
+                    self.resting = 0
+
+                # animation, running enemy images alternatetion
+                if self.direction > 0:
+                    direction = SpriteConstants.RIGHT
+                else:
+                    direction = SpriteConstants.LEFT
+
+                if self.alternate == 1:
+                    self.updateSprite(SpriteConstants.START_RUNNING, direction)
+                if self.alternate == 4 or self.alternate == 10:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+                if self.alternate == 7:
+                    self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+                self.alternate += 1
+                if self.alternate > 12:
+                    self.alternate = 1
+
+                #  changes the image when enemy jumps
+                if self.resting == 0:
+                   if self.direction == -1:
+                       self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+                   else:
+                       self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            else:
+                # animation, standing up images
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+
+            # restart enemy's timer from time to time, so that he stops moving.
+            if atack3 == 1:
+                self.timeenemy = 20
+                # puts the enemy turned to the player's direction
+                if game.enemymode == 'static':
+                    if game.player.rect.right < self.rect.left:
+                        self.direction = -1
+                    elif game.player.rect.left > self.rect.right:
+                        self.direction = 1
+                else:
+                    self.direction = self.direction * -1
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*1))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*1))
+
+                # pushes player when he collides with the enemy
+                game.player.rect.x +=  self.direction *  50 * dt
+
+                # limits the player to stand on the screem space even being pushed
+                if game.player.rect.x < 60:
+                    game.player.rect.x = 60
+                if game.player.rect.x > 620:
+                    game.player.rect.x = 620
+
+                # sets flag to change the player image when he is hurt
+                game.player.hurt = 5
+
+            # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+
+            # enemy shoots
+            if atack4 == 1:
+
+                self.shooting = 5
+                self.gun_cooldown = 3
+
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                # shoots 4 bullets placed in fixed places - bullets coming from the enemy.
+                for i in range (0,4):
+
+                    ay = [-10,-10,20,-45]
+
+                    if self.direction > 0:
+                        ax = [-24,50,1,1]
+                        self.twists.append(Bullet_e3((self.rect.x+ax[i],self.rect.y-ay[i]), 1, 'h', len(self.twists), game.sprite_e))
+                    else:
+                        ax = [25,-50,-7,-7]
+                        self.twists.append(Bullet_e3((self.rect.x-ax[i],self.rect.y-ay[i]), -1, 'h', len(self.twists), game.sprite_e))
+
+                # shoots 4 bullets placed in fixed places - bullets coming from the top of the screen
+                aux = 100
+                for i in range (0,4):
+                    self.twists.append(Bullet_e3((aux,100), 1, 'v',len(self.twists),game.sprite_e))
+                    aux = aux + 150
+
+            # decreases time for bullets limitation
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)
+
+            # hurt enemy animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+            # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+# enemy's bullet
+class Bullet_e3(pygame.sprite.Sprite):
+
+
+
+    image = pygame.image.load('evoman/images/met.png')
+
+    def __init__(self, location, direction, btype, n_twist, *groups):
+        super(Bullet_e3, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.lifespan = 100
+        self.btype = btype
+        self.swingtime = 0
+        self.n_twist = n_twist
+
+
+
+    def update(self, dt, game):
+
+
+        if game.time%2==0:
+            self.image = pygame.image.load('evoman/images/met.png')
+        else:
+            self.image = pygame.image.load('evoman/images/met2.png')
+
+
+        # decreases bullet's timer
+        self.lifespan -= 1
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # moves the bullets
+        if self.btype == 'h':  # bullets that come from the enemy
+            if self.lifespan <= 50:
+                self.rect.x += self.direction * 550 * dt
+        else:
+            if self.lifespan <= 60: # bullets that come from the top
+                self.rect.y += 300 * dt
+
+                # animation of the bullets swinging
+                self.swingtime += 1
+
+                if self.swingtime == 10:
+                    self.rect.x += self.direction * 1000 * dt
+                    self.direction = self.direction * -1
+                    self.swingtime = 0
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, accoring to the difficult level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*1))
+
+            # pushes player when he collides with the enemy
+            game.player.rect.x +=  self.direction *  100 * dt
+
+            # limits the player to stand on the screen space even being pushed.
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+            # sets flag to change the player image when he is hurt
+            game.player.hurt = 5
+
+        # removes player's bullets when colliding with enemy's bullets
+        aux = 0
+        for t in game.player.twists:
+            if t != None:
+                if self.rect.colliderect(t.rect):
+                    t.kill()
+                    game.player.twists[aux] = None
+            aux += 1
Index: NEAT/evoman/enemy4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy4.py b/NEAT/evoman/enemy4.py
new file mode 100644
--- /dev/null	(date 1632487473331)
+++ b/NEAT/evoman/enemy4.py	(date 1632487473331)
@@ -0,0 +1,327 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map2.tmx'
+timeexpire = 1500 # game run limit
+
+# enemy 4 sprite, heatman
+class Enemy(pygame.sprite.Sprite):
+
+
+
+    def __init__(self, location,*groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.twists = []
+        self.alternate = 1
+        self.fireflash = 0
+        self.imune = 0
+        self.rect.x = 550
+        self.timeenemy = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+        self.rect.right = 580
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+
+        # defines game mode for player action
+        if game.enemymode == 'static': # enemy controlled by static movements
+
+            if self.timeenemy == 2:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if self.timeenemy> 50:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy == 3:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            if (self.fireflash>=1 and self.fireflash <=40):
+                atack4 = 1
+            else:
+                atack4 = 0
+
+        elif game.enemymode == 'ai': # player controlled by AI algorithm
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 4:
+                game.print_logs("ERROR: Enemy 1 controller must return 4 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+
+            if atack3 == 1 and not self.gun_cooldown:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+
+
+        # if the 'start game' marker is 1
+        if game.start == 1:
+
+            self.timeenemy += 1 # increments enemy timer
+
+            last = self.rect.copy()  # copies last position state of the enemy
+
+
+            # when player atacks, enemy turns into fire and goes towards his direction
+            if game.player.atacked == 1 and self.fireflash == 0:
+                self.fireflash = 100
+            else:
+                self.fireflash = max(0,self.fireflash -1)
+
+            if  atack4 == 1:
+                self.rect.x += self.direction * 600 * dt
+
+                if self.fireflash == 1:
+                    self.direction = self.direction * -1
+
+                if  self.rect.colliderect(game.player.rect):
+                    self.fireflash = 0
+
+            # otherwise he just keeps shooting towards the player direction
+            elif self.fireflash == 0:
+
+                if atack1 == 1 and self.resting == 1:
+                    self.dy = -900
+                    self.resting = 0
+
+                self.imune = 0  # enemy is not imune to player's shooting anymore
+
+                # images of the enemy standing up
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+            # reinicializes timer and turns to the players direction
+            if atack2 == 1:
+                self.timeenemy = 1
+
+                if game.enemymode == 'static':
+                    if game.player.rect.right < self.rect.left:
+                        self.direction = -1
+                    elif game.player.rect.left > self.rect.right:
+                        self.direction = 1
+                else:
+                   self.direction = self.direction *-1
+
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*0.3))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*0.3))
+
+                # pushes player when he collides with the enemy
+                game.player.rect.x +=  self.direction *  50 * dt
+
+                # limits the player to stand on the screen space even being pushed
+                if game.player.rect.x < 60:
+                    game.player.rect.x = 60
+                if game.player.rect.x > 620:
+                    game.player.rect.x = 620
+
+                # sets flag to change the player image when he is hurt
+                game.player.hurt = 5
+
+             # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+
+            # enemy shoots 3 bullets
+            if atack3 == 1:
+
+                self.shooting = 5
+
+                self.gun_cooldown = 5
+
+                # if enemy is not turned into fire, shoots, otherwise stops the time counter for a while.
+                if self.fireflash == 0:
+
+                    # bullets sound effect
+                    if game.sound == "on" and game.playermode == "human":
+                        sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                        c = pygame.mixer.Channel(3)
+                        c.set_volume(10)
+                        c.play(sound)
+
+
+                    for i in range (0,3):
+                        self.twists.append(Bullet_e4((self.rect.x ,self.rect.y ), self.direction, i, len(self.twists), game.sprite_e))
+                else :
+                    self.timeenemy -= 1
+
+
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)  # decreases time for bullets limitation.
+
+           # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+            #  changes the image when enemy is hurt and imune, as a fireball
+            if self.imune == 1:
+                if game.time%2==0:
+                    self.image = pygame.image.load('evoman/images/fireball.png')
+                else:
+                    self.image = pygame.image.load('evoman/images/fireball2.png')
+
+            self.hurt -=1
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+
+# enemy bullets
+class Bullet_e4(pygame.sprite.Sprite):
+
+    image = pygame.image.load('evoman/images/bullet_l.png')
+
+    def __init__(self, location, direction, n, n_twist, *groups):
+        super(Bullet_e4, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.lifespan = 30
+        self.n= n
+        self.n_twist = n_twist
+
+    def update(self, dt, game):
+
+
+        # puts the bullets in positions relative to the player. They go from the enemy to where the player is.
+        if self.n == 0:
+            aux_x = 50
+            aux_y = (abs(game.player.rect.x - game.enemy.rect.x)*0.55)
+        elif self.n == 1:
+            aux_x = 20
+            aux_y = (abs(game.player.rect.x - game.enemy.rect.x)*0.60)
+        elif self.n == 2:
+            aux_x = -10
+            aux_y = (abs(game.player.rect.x - game.enemy.rect.x)*0.65)
+
+        # bullets axis x movement
+        if self.direction == -1:
+            if self.rect.x > game.player.rect.left + aux_x:
+                self.rect.x += self.direction *  650  * dt
+        else:
+            if self.rect.x < game.player.rect.right - aux_x:
+                self.rect.x += self.direction *  650  * dt
+
+        # bullets axis y movements
+        if self.direction == -1:
+             if self.rect.x > game.player.rect.left + aux_y:
+                 self.rect.y -=  500 * dt
+             else:
+                 self.rect.y +=  700 * dt
+        else:
+             if self.rect.x < game.player.rect.right - aux_y-10:
+                 self.rect.y -=  500 * dt
+             else:
+                 self.rect.y +=  700 * dt
+
+        # prevents bullets from passing through the floor
+        self.rect.y = min(410,self.rect.y)
+
+        # removes old bullets
+        if self.rect.y == 410:
+            self.lifespan -= 1
+
+        if self.lifespan < 0:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        if self.rect.right<1 or self.rect.left>736 or  self.rect.top <1 or self.rect.bottom>512 :
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, accoring to the difficulty level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+            # pushes player when he collides with the enemy
+            game.player.rect.x +=  self.direction *  100 * dt
+
+           # limits the player to stand on the screen space even being pushed
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+            # sets flag to change the player image when he is hurt
+            game.player.hurt = 5
Index: NEAT/evoman/enemy5.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy5.py b/NEAT/evoman/enemy5.py
new file mode 100644
--- /dev/null	(date 1632487473331)
+++ b/NEAT/evoman/enemy5.py	(date 1632487473331)
@@ -0,0 +1,317 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map2.tmx'
+timeexpire = 1000 # game run limit
+
+# enemy 5 sprite, metalman
+class Enemy(pygame.sprite.Sprite):
+
+
+
+
+    def __init__(self, location,*groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.alternate = 1
+        self.direction_floor = 1
+        self.imune = 0
+        self.move = 0
+        self.countmove = 0
+        self.rect.x = 500
+        self.timeenemy = 0
+        self.twists = []
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+        # Defines game mode for player action.
+        if game.enemymode == 'static': # Enemy controlled by static movements.
+
+            if self.resting == 1 and self.timeenemy >= 95 and self.timeenemy <= 110:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if self.resting == 0 :
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if (game.player.rect.right < game.enemy.rect.left and  abs(game.player.rect.right - game.enemy.rect.left) <= 50 ) or (game.enemy.rect.right < game.player.rect.left and abs(game.enemy.rect.right - game.player.rect.left) <= 50):
+                atack3 = 1
+            else:
+                atack3 = 0
+
+
+        elif game.enemymode == 'ai': # Player controlled by AI algorithm.
+
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 3:
+                game.print_logs("ERROR: Enemy 1 controller must return 3 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+
+
+
+            if atack2 == 1 and not self.gun_cooldown:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+
+        # if the 'start game' marker is 1
+        if game.start == 1:
+
+
+            self.timeenemy += 1 # increments enemy timer
+
+            # moving floor, changes the movement direction from time to time.
+            for cell in game.tilemap.layers['triggers'].collide(game.player.rect, 'blockers'):
+
+                blockers = cell['blockers']
+                if 't' in blockers:
+
+                    game.player.rect.x += self.direction_floor * 100 * dt # moves player over the moving floor
+
+                    # limits player inside the screen
+                    if game.player.rect.left < 60:
+                        game.player.rect.left = 61
+                    if game.player.rect.right > 665:
+                        game.player.rect.right = 665
+
+                if game.time%120 == 0:
+                    self.direction_floor = self.direction_floor *-1
+
+
+            last = self.rect.copy() # copies last position state of the enemy
+
+            # if player gets too close to the enemy, he jumps to the other side.
+            if (self.resting == 1 and atack3 == 1):
+                self.move = 1
+                self.dy = -900
+                self.resting = 0
+
+            if self.move == 1:
+                self.rect.x += self.direction * 900 * dt
+
+            if self.move == 1 and self.rect.x<200:
+                self.rect.x = 200
+                self.direction = self.direction  * -1
+                self.move = 0
+            if self.move == 1 and  self.rect.x>500:
+                self.rect.x = 500
+                self.direction = self.direction  * -1
+                self.move = 0
+
+
+            # jumps from time to time or when player atacks
+            if ( (self.resting == 1 and atack1 == 1) or ( self.resting == 1 and game.player.atacked == 1)):
+                self.dy = -900
+                self.resting = 0
+
+            # releases until 4 bullets (decided randomly) after jumping or when player atacks
+            if (atack2 == 1 and not self.gun_cooldown) :
+
+                self.shooting = 5
+
+                self.gun_cooldown = 3
+
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                aux = numpy.random.randint(1,4)
+                for i in range(0,aux):
+                    self.twists.append(Bullet_e5((self.rect.x + (self.direction*(i*30)) ,self.rect.top + (self.direction*(i*20))  ), self.direction, game.player.rect , len(self.twists), game.sprite_e))
+
+
+                self.timeenemy = 0 # reinicializes enemy timer
+
+            if game.player.atacked == 1:
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                self.twists.append(Bullet_e5((self.rect.x ,self.rect.top ), self.direction, game.player.rect , len(self.twists), game.sprite_e))
+
+
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)   # decreases time for bullets limitation
+
+            # animation, running enemy images alternation.
+            if self.direction > 0:
+                direction = SpriteConstants.RIGHT
+            else:
+                direction = SpriteConstants.LEFT
+
+            if self.alternate == 1:
+                self.updateSprite(SpriteConstants.START_RUNNING, direction)
+            if self.alternate == 4 or self.alternate == 10:
+                self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+            if self.alternate == 7:
+                self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+            self.alternate += 1
+            if self.alternate > 12:
+                self.alternate = 1
+
+            #  changes the image when enemy jumps
+            if self.resting == 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*0.3))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*0.3))
+
+                # pushes player when he collides with the enemy
+                game.player.rect.x +=  self.direction *  50 * dt
+
+                # limits the player to stand on the screen space even being pushed.
+                if game.player.rect.x < 60:
+                    game.player.rect.x = 60
+                if game.player.rect.x > 620:
+                    game.player.rect.x = 620
+
+            # gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+            # hurt enemy animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+           # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+# enemy bullets
+class Bullet_e5(pygame.sprite.Sprite):
+
+
+
+    image = pygame.image.load('evoman/images/blade.png')
+
+    def __init__(self, location, direction, pos_p, n_twist, *groups):
+        super(Bullet_e5, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.pos_p = pos_p
+        self.n_twist = n_twist
+
+
+    def update(self, dt, game):
+
+
+        # bullets go the player's  direction marked at the shooting time
+        self.rect.x += self.direction *  550 * dt
+        if self.rect.bottom < self.pos_p.bottom:
+            self.rect.y +=  300  * dt
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, according to the difficulty level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+
+            game.player.rect.x +=  self.direction *  100 * dt # pushes player when he collides with the enemy
+
+           # limits the player to stand on the screen space even being pushed
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+
+            game.player.hurt = 5 # sets flag to change the player image when he is hurt
Index: NEAT/evoman/enemy6.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy6.py b/NEAT/evoman/enemy6.py
new file mode 100644
--- /dev/null	(date 1632487473346)
+++ b/NEAT/evoman/enemy6.py	(date 1632487473346)
@@ -0,0 +1,296 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map2.tmx'
+timeexpire = 2200 # game run limit
+
+# enemy 6 sprite, crashman
+class Enemy(pygame.sprite.Sprite):
+
+
+
+
+    def __init__(self, location, *groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.twists = []
+        self.alternate = 1
+        self.just_shoot = 0
+        self.imune = 0
+        self.timeenemy = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+
+
+
+    def update(self, dt, game):
+
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+
+        # Defines game mode for player action.
+        if game.enemymode == 'static': # Enemy controlled by static movements.
+
+            if self.timeenemy == 105:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+            if ( (abs(self.rect.left-game.player.rect.left)<=1 or abs(self.rect.right-game.player.rect.right)<=1)  or self.dy>200  ):
+                atack2 = 1
+            else:
+                atack2 = 0
+
+
+            atack3 = 0
+
+
+        elif game.enemymode == 'ai': # Player controlled by AI algorithm.
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)
+            if len(actions) < 3:
+                game.print_logs("ERROR: Enemy 1 controller must return 3 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+
+
+
+            if atack2 == 1 and not self.gun_cooldown:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+
+        # if the 'start game' marker is 1
+        if game.start == 1:
+
+            self.timeenemy += 1 # increments enemy timer
+
+            last = self.rect.copy() # copies last position state of the enemy
+
+            # movements of the enemy on the axis x until a limit (turning aroud)
+
+            if self.rect.left<60:
+                self.direction = self.direction  * -1
+                self.rect.left = 60
+            if self.rect.right>680:
+                self.direction = self.direction  * -1
+                self.rect.right = 680
+
+            # calculating the relative distance between enemy and player to set the jumping strengh
+            aux_dist = (abs(game.player.rect.right - self.rect.right)/490.0)+0.1
+
+            # when atacking, enemy may accelarate his movement.
+            if self.dy<0:
+                self.rect.x += self.direction * (1500 *aux_dist) * dt
+            else:
+                self.rect.x += self.direction * 180 * dt
+
+            #  jumps over the player. It happens from time to time, or when the player shoots.
+            if ((self.resting == 1 and atack1 == 1) or ( self.resting == 1 and game.player.atacked == 1)):
+
+                if game.enemymode == 'static':
+                    # enemy turns to the players direction.
+                    if game.player.rect.right <= self.rect.left:
+                        self.direction = -1
+                    if game.player.rect.left >= self.rect.right:
+                        self.direction = 1
+
+                # reinicializes enemy timer
+                self.timeenemy = 0
+
+                self.dy = -1500 * aux_dist
+                self.resting = 0
+
+            if atack3 == 1 and game.enemymode == 'ai':
+                 self.direction = self.direction * -1
+
+            # throws a bullet over the player when enemy is jumping and right over him
+            if self.resting == 0 and self.just_shoot == 0 and atack2 == 1:
+
+                self.shooting = 5
+                self.gun_cooldown = 3
+
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                self.just_shoot = 1
+
+                self.twists.append(Bullet_e6((self.rect.x ,self.rect.y ), self.direction, len(self.twists), game.sprite_e))
+
+
+            self.gun_cooldown = max(0, self.gun_cooldown - dt) # decreases time for bullets limitation
+
+            # animation, running enemy images alternation
+            if self.direction > 0:
+                direction = SpriteConstants.RIGHT
+            else:
+                direction = SpriteConstants.LEFT
+
+            if self.alternate == 1:
+                self.updateSprite(SpriteConstants.START_RUNNING, direction)
+            if self.alternate == 4 or self.alternate == 10:
+                self.updateSprite(SpriteConstants.RUNNING_STEP1, direction)
+            if self.alternate == 7:
+                self.updateSprite(SpriteConstants.RUNNING_STEP2, direction)
+
+            self.alternate += 1
+            if self.alternate > 12:
+                self.alternate = 1
+
+            #  changes the image when enemy jumps
+            if self.resting == 0:
+               if self.direction == -1:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+               else:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*0.3))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*0.3))
+
+                game.player.rect.x +=  self.direction *  50 * dt   # pushes player when he collides with the enemy
+
+                # limits the player to stand on the screen space even being pushed
+                if game.player.rect.x < 60:
+                    game.player.rect.x = 60
+                if game.player.rect.x > 620:
+                    game.player.rect.x = 620
+
+                game.player.hurt = 5  # sets flag to change the player image when he is hurt
+
+            #  gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+                    self.just_shoot = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+            # hurt enemy animation
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+            # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+# enemy's bullet
+class Bullet_e6(pygame.sprite.Sprite):
+
+
+
+    image = pygame.image.load('evoman/images/mi2.png')
+
+    def __init__(self, location, direction, n_twist, *groups):
+        super(Bullet_e6, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.lifespan = 70
+        self.n_twist = n_twist
+
+
+    def update(self, dt, game):
+
+
+        self.rect.y +=  500 * dt  # moves the bullets
+
+        self.rect.y = min(410,self.rect.y) # prevents bullets from passing throught the floor
+
+        self.lifespan -= 1 #  decreases bullet's timer
+
+        # removes old bullets
+        if self.lifespan < 0:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, according to the difficulty level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+
+            game.player.rect.x +=  self.direction *  100 * dt # pushes player when he collides with the enemy
+
+            # limits the player to stand on the screen space even being pushed
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+
+            game.player.hurt = 5 # sets flag to change the player image when he is hurt
Index: NEAT/evoman/enemy7.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NEAT/evoman/enemy7.py b/NEAT/evoman/enemy7.py
new file mode 100644
--- /dev/null	(date 1632487473346)
+++ b/NEAT/evoman/enemy7.py	(date 1632487473346)
@@ -0,0 +1,375 @@
+################################
+# EvoMan FrameWork - V1.0 2016 #
+# Author: Karine Miras         #
+# karine.smiras@gmail.com      #
+################################
+
+import sys
+import numpy
+import random
+
+import Base
+from Base.SpriteConstants import *
+from Base.SpriteDefinition import *
+from sensors import Sensors
+
+tilemap = 'evoman/map4.tmx'
+timeexpire = 1000 # game run limit
+
+# enemy 7 sprite, bubbleman
+class Enemy(pygame.sprite.Sprite):
+
+
+    def __init__(self, location, *groups):
+        super(Enemy, self).__init__(*groups)
+        self.spriteDefinition = SpriteDefinition('evoman/images/EnemySprites.png', 0, 0, 43, 59)
+        self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = -1
+        self.max_life = 100
+        self.life = self.max_life
+        self.resting = 0
+        self.dy = 0
+        self.alternate = 1
+        self.imune = 0
+        self.timeenemy = 0
+        self.twists = []
+        self.bullets = 0
+        self.hurt = 0
+        self.shooting = 0
+        self.gun_cooldown = 0
+        self.gun_cooldown2 = 0
+
+
+
+    def update(self, dt, game):
+
+        if game.time==1:
+            # puts enemy in random initial position
+            if game.randomini == 'yes':
+                self.rect.x = numpy.random.choice([640,500,400,300])
+
+
+        # defines game mode for player actionv
+        if game.enemymode == 'static': # enemy controlled by static movements
+
+            if self.timeenemy>=4 and self.timeenemy<=20 and  self.timeenemy%4 == 0:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+
+            atack2 = 1 #useless
+
+
+            if self.timeenemy==4:
+                atack2 = 1
+            else:
+                atack2 = 0
+
+            if self.timeenemy==5:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+            if self.timeenemy>=50 and  self.timeenemy<80:
+                atack4 = 1
+            else:
+                atack4 = 0
+
+            if self.timeenemy == 50:
+                atack5 = 1
+            else:
+                atack5 = 0
+
+            if self.timeenemy == 100:
+                atack6 = 1
+            else:
+                atack6 = 0
+
+
+        elif game.enemymode == 'ai': # Player controlled by AI algorithm.
+
+
+
+            # calls the controller providing game sensors
+            actions = game.enemy_controller.control(self.sensors.get(game), game.econt)  
+            if len(actions) < 6:
+                game.print_logs("ERROR: Enemy 1 controller must return 6 decision variables.")
+                sys.exit(0)
+
+            atack1 = actions[0]
+            atack2 = actions[1]
+            atack3 = actions[2]
+            atack4 = actions[3]
+            atack5 = actions[4]
+            atack6 = actions[5]
+
+
+            if atack1 == 1 and not self.gun_cooldown2:
+                atack1 = 1
+            else:
+                atack1 = 0
+
+
+            if atack3 == 1 and not self.gun_cooldown:
+                atack3 = 1
+            else:
+                atack3 = 0
+
+
+        # marks the flag indicating to the player that the map is on water environment
+        game.player.inwater = 1
+
+        # if the 'start game' marker is 1
+        if game.start == 1:
+
+            # increments enemy timer
+            self.timeenemy += 1
+
+            # copies last position state of the enemy
+            last = self.rect.copy()
+
+            # calculates a relative distance factor, between the player and enemy to set up the jumping strengh
+            aux_dist = (abs(game.player.rect.right - self.rect.right)/490.0)+0.3
+
+            # shoots 5 bullets positioned over the same range
+            if atack1 == 1:
+
+                self.shooting = 5
+
+                self.gun_cooldown2 = 3
+
+
+                # bullets sound effect
+                if game.sound == "on" and game.playermode == "human":
+                    sound = pygame.mixer.Sound('evoman/sounds/scifi011.wav')
+                    c = pygame.mixer.Channel(3)
+                    c.set_volume(10)
+                    c.play(sound)
+
+                rand = numpy.random.randint(0, 25, 1)
+                self.twists.append(Bullet_e7((self.rect.x,self.rect.y), self.direction, len(self.twists), game.sprite_e))
+
+
+            # throws from 1 to 3 bubbles, starting at slighly different positions
+
+            if self.bullets == 0: # if the bubblues have gone away, enemy is abble to realease new bubbles.
+
+                rand = 2
+                for i in range(0,rand):
+                    if atack3 == 1:
+
+                        self.gun_cooldown = 3
+
+                        self.bullets += 1
+                        self.twists.append(Bullet_e72((self.rect.x+self.direction*i*30  ,self.rect.y-i*30), self.direction, len(self.twists), game.sprite_e))
+
+            # decreases time for bullets limitation
+            self.gun_cooldown = max(0, self.gun_cooldown - dt)
+
+            # decreases time for bullets limitation
+            self.gun_cooldown2 = max(0, self.gun_cooldown2 - dt)
+
+            # enemy moves during some time, after standing still for a while
+            if atack4 == 1:
+                   self.rect.x += self.direction * 600 * aux_dist * dt * 0.7
+
+            #  enemy jumps while is moving
+            if self.resting == 1 and atack5 == 1:
+                self.dy = -1500
+                self.resting = 0
+
+            # at the end of the atack cicle, enemy turns over the players direction.
+            if atack6 == 1:
+               if game.enemymode == 'static':
+                   if game.player.rect.right < self.rect.left:
+                       self.direction = -1
+                   if game.player.rect.left > self.rect.right:
+                        self.direction = 1
+               else:
+                   self.direction = self.direction * -1
+
+               # reinicializes enemy timer
+               self.timeenemy = 0
+
+            #  gravity
+            self.dy = min(400, self.dy + 100)
+            self.rect.y += self.dy * dt * 0.4
+
+            #  changes the image when enemy jumps or stands up
+            if self.resting == 0:
+               if self.direction == -1:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.LEFT)
+               else:
+                   self.updateSprite(SpriteConstants.JUMPING, SpriteConstants.RIGHT)
+            else:
+               if self.direction == -1:
+                   self.updateSprite(SpriteConstants.STANDING, SpriteConstants.LEFT)
+               else:
+                   self.updateSprite(SpriteConstants.STANDING, SpriteConstants.RIGHT)
+
+            # checks collision of the player with the enemy
+            if self.rect.colliderect(game.player.rect):
+
+                # choses what sprite penalise according to config
+                if game.contacthurt == "player":
+                    game.player.life = max(0, game.player.life-(game.level*0.3))
+                if game.contacthurt == "enemy":
+                    game.enemy.life = max(0, game.enemy.life-(game.level*0.3))
+
+
+                game.player.rect.x +=  self.direction *  50 * dt   # pushes player when he collides with the enemy
+
+                # limits the player to stand on the screen space even being pushed
+                if game.player.rect.x < 60:
+                    game.player.rect.x = 60
+                if game.player.rect.x > 620:
+                    game.player.rect.x = 620
+
+                if self.rect.x < 70:
+                    self.rect.x = 70
+                if self.rect.x > 610:
+                    self.rect.x = 610
+
+
+                game.player.hurt = 5 # Sets flag to change the player image when he is hurt.
+
+            # controls screen walls and platforms limits agaist enemy
+            new = self.rect
+            self.resting = 0
+            for cell in game.tilemap.layers['triggers'].collide(new, 'blockers'):
+
+                blockers = cell['blockers']
+
+                if 'l' in blockers and last.right <= cell.left and new.right > cell.left:
+                    new.right = cell.left
+
+                if 'r' in blockers and last.left >= cell.right and new.left < cell.right:
+                    new.left = cell.right
+
+                if 't' in blockers and last.bottom <= cell.top and new.bottom > cell.top:
+                    self.resting = 1
+                    new.bottom = cell.top
+                    self.dy = 0
+
+                if 'b' in blockers and last.top >= cell.bottom and new.top < cell.bottom:
+                    new.top = cell.bottom
+
+            # hurt enemy image
+            if self.hurt > 0:
+                if self.direction == -1:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.LEFT)
+                else:
+                   self.updateSprite(SpriteConstants.HURTING, SpriteConstants.RIGHT)
+
+            self.hurt -=1
+
+            # changes bullets images according to the enemy direction
+            if self.shooting > 0:
+                if self.direction == -1:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.LEFT)
+                else:
+                    self.updateSprite(SpriteConstants.SHOOTING, SpriteConstants.RIGHT)
+
+            self.shooting -= 1
+            self.shooting = max(0,self.shooting)
+
+    def updateSprite(self, state, direction):
+        self.image = self.spriteDefinition.getImage(state, direction)
+
+
+# enemy's bullet
+class Bullet_e7(pygame.sprite.Sprite):
+
+    image = pygame.image.load('evoman/images/bullet2_l.png')
+
+    def __init__(self, location, direction, n_twist, *groups):
+        super(Bullet_e7, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.n_twist = n_twist
+
+
+
+    def update(self, dt, game):
+
+
+        self.rect.x +=  self.direction * 500 * dt  # moves the bullets on the axis x
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, accoring to the difficult level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+
+            game.player.rect.x +=  self.direction *  100 * dt  # pushes player when he collides with the enemy
+
+            # limits the player to stand on the screen space even being pushed
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+            # sets flag to change the player image when he is hurt
+            game.player.hurt = 1
+        else:
+            game.player.hurt = 0
+
+
+
+# enemy's bullet 2 (bubble)
+class Bullet_e72(pygame.sprite.Sprite):
+
+    image = pygame.image.load('evoman/images/bubb.png')
+
+    def __init__(self, location, direction, n_twist, *groups):
+        super(Bullet_e72, self).__init__(*groups)
+        self.rect = pygame.rect.Rect(location, self.image.get_size())
+        self.direction = direction
+        self.direc = 1
+        self.n_twist = n_twist
+
+
+
+    def update(self, dt, game):
+
+
+        self.rect.x +=  self.direction * 200 * dt * 0.5      # moves the bullets on the axis x
+
+        # moves the bullets on the axis y. Go up and down according to the floor and imaginary top.
+        self.rect.y += 200 * self.direc * dt * 0.4
+        if self.rect.y >= 460 or self.rect.y <= 350:
+            self.direc = self.direc * -1
+
+        # removes bullets objetcs when they transpass the screen limits
+        if self.rect.right < 1 or self.rect.left>736 or self.rect.bottom < 1  or self.rect.top > 512:
+            self.kill()
+            game.enemy.twists[self.n_twist] = None
+            game.enemy.bullets -=1
+            return
+
+        # checks collision of enemy's bullet with the player
+        if self.rect.colliderect(game.player.rect):
+
+            # player loses life points, according to the difficulty level of the game (the more difficult, the more it loses).
+            game.player.life = max(0, game.player.life-(game.level*0.3))
+
+            game.player.rect.x +=  self.direction *  100 * dt # pushes player when he collides with the enemy
+
+            # limits the player to stand on the screen space even being pushed
+            if game.player.rect.x < 60:
+                game.player.rect.x = 60
+            if game.player.rect.x > 620:
+                game.player.rect.x = 620
+
+
+            game.player.hurt = 5 # sets flag to change the player image when he is hurt
diff --git a/NEAT/evoman/Base/__init__.py b/NEAT/evoman/Base/__init__.py
new file mode 100644
